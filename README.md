% A Unified Executors Proposal for C++ | P0443R1

----------------    -------------------------------------
Title:              A Unified Executors Proposal for C++

Authors:            Jared Hoberock, jhoberock@nvidia.com

                    Michael Garland, mgarland@nvidia.com

                    Chris Kohlhoff, chris@kohlhoff.com

                    Chris Mysen, mysen@google.com

                    Carter Edwards, hcedwar@sandia.gov

                    Gordon Brown, gordon@codeplay.com

Other Contributors: Hans Boehm, hboehm@google.com

                    Thomas Heller, thom.heller@gmail.com

                    Lee Howes, lwh@fb.com

                    Bryce Lelbach, brycelelbach@gmail.com

                    Hartmut Kaiser, hartmut.kaiser@gmail.com

                    Bryce Lelbach, brycelelbach@gmail.com

                    Gor Nishanov, gorn@microsoft.com

                    Thomas Rodgers, rodgert@twrodgers.com

                    David Hollman, dshollm@sandia.gov

                    Michael Wong, michael@codeplay.com

Document Number:    P0443R1

Date:               2017-01-06

Audience:           SG1 - Concurrency and Parallelism

Reply-to:           jhoberock@nvidia.com

------------------------------------------------------

# Introduction

This paper describes a programming model for executors, which are modular
components for creating execution. Executors decouple software from the
disparate, non-uniform interfaces of execution resources and present a uniform
interface for work creation. The model proposed by this paper represents what
we believe is the functionality necessary to compose executors with existing
standard control structures such as `std::async()` and parallel algorithms, as
well as near-standards such as the functionality found in various technical
specifications, including the Concurrency, Networking, and Parallelism TSes. We
intend this proposal to be an extensible basis for future development of
execution in C++ which necessarily entails functionality beyond the scope of
this basic proposal.

## Concepts and Terms

  An *executor* executes callable function objects.

Our **executor** proposal addresses many (but not necessarily all)
of the semantic and performance consideratons assocated with
executing callable function objects.

Contemporary hardware and runtime facilities capable of executing
callable function objects are heterogeneous; e.g., CPU cores,
*lightweight* CPU cores, GPU cores, OS runtime, embedded runtime,
or database runtime.
While this proposal does not address this heterogeneity, it must
eventually be addressed for a uniform *executor* programming model
to utilize heterogeneous facilities.

An **execution architecture** defines facilities available and contraints 
imposed on callable function objects that execute on hardware/runtime
of that architecture.
For example, callable function objects executing on a CPU via `std::thread`
will typically have complete access to operating system, filesystem,
networking, and similar facilities.  In contrast callable function objects
executing on a GPU may not have access to filesystems and access to a limited
set of runtime facilities.
 
A program may have access to more than one **execution resource**
of a given execution architecture.  For example, contemporary CPUs have
multiple cores of same architecture and an instance of an execution
resource denotes a particular core (or hyperthread).
Programmers concerned with concurrent or parallel execution performance
often need to explicitly manage utilization of execution resources.
For example, a thread pool may be constrained to execute callable function
objects on a specified set of cores.
Furthermore, execution resources can have performance affinity with
respect to memory and programmers concerned with performance need to
reason about the locality between memory and the execution of function objects
accessing that memory (e.g., NUMA regions).

An **execution context** is a program object that represents a specific
collection of execution resources.
 
An **executor** is an object associated with a specific execution context.
It provides a mechanism(s) for creating *execution agents* that
execute callable function objects. The agents created are bound to the
executor's execution context, and hence to specific execution resources.

The primary objective of this paper is to define the initial abstractions,
semantics, and interface for a suite of executors.
A secondary objective is to establish conceptual framework for future
papers to address evolving *ecosystem* of executors, execution contexts,
execution resources, and execution architectures.


## Design goals

The design outlined in this proposal is intended to achieve
our goals for executors, which are objects for creating all kinds of execution
in C++. Executors should be *composable*, *adaptable*, and *customizable*,
which we believe reflects the needs of users, library implementors, and
executor authors, respectively. Short code examples demonstrating how our
design accomodates the needs of these different audiences may be found in
the [Appendix](#code-examples).
   
By *composable*, we mean that executors should cross software boundaries
allowing disparate software components to interoperate using a
commonly-understood protocol. By *adaptable*, we mean that executors
specially-designed for a particular use case should be applicable in other
use cases when it is possible. By *customizable*, we mean that requirements
placed on executors should be broad enough to encompass user-defined
executors, rather than limited to the set of concrete executors which may
eventually become part of the C++ Standard Library. Only a design including
well-defined interfaces with clear semantics will achieve these goals.

## Customization Points

In our design, these well-defined interfaces with
clearly-expressed execution semantics are called executor *customization
points* and are foundational to the mechanics of our design. Each executor
customization point is a function which delineates a specific use case which we
have identified as fundamental to the needs of the C++ Standard Library and
other technical specifications for execution creation. For example, the
customization point `execution::async_execute()` asynchronously creates a
single execution agent to invoke a given function and returns a future
corresponding to that function's eventual result. A C++ Standard Library
function like `std::async()` may compose with a user-supplied executor by using
calling `execute::async_execute()` in its implementation. As another example,
        the customization point `execution::sync_execute()` synchronously
        creates a single execution agent to invoke a given function and
        immediately returns that function's result. These semantics provide a
        natural fit for the composition of user-provided executors with
        `std::invoke()`.

Because we envision executors to be the workhorses of execution in generic
code, it is critical that they be adaptable to a variety of use cases. For
example, a generic function like `std::invoke()` should be interoperable with
as many types of executor as possible, not just that set of executors which
natively provide the synchronous, single-agent execution function
`sync_execute()`. To generalize across use cases, we have designed executor
customization points to adapt the behavior of an executor when its native
behavior is not a precise match for the use case of interest. For example,
`std::invoke()` may interoperate with an executor which natively
provides the execution function `async_execute()` by calling the
customization point `execution::sync_execute()`. This customization
point will adapt the executor by calling its natively provided
`async_execute()` execution function, and wait on the resulting
future. In this way, generic code may uniformly compose with executors
with minimal restriction.

These adaptations performed by executor customization points are always
performed in such a way as to ensure that various semantic guarantees provided
by executors are never weakened. For example, if an executor guarantees that
its possibly-blocking execution functions are always non-blocking, then an
adapted implementation of `execution::async_execute` will always be
non-blocking when that executor is composed with this customization point.

Our design focuses on defining a set of optional execution functions instead of
imposing a set of strict executor requirements to maximize the latitude of
executor authors. Rather than prematurely attempt to circumscribe the universe
of all possible executors with a set of universal requirements, we believe it
is more flexible to identify a set of use cases for work creation which can
grow in the future. Executor authors may choose to natively support one or more
of these use cases by implementing the appropriate execution function, and may
opt in to natively supporting new use cases as they are introduced. Due to
their adaptability, an executor will be future-proof to new customization
points.

The following diagram shows the automatic adaptations performed by the
customization points, assuming a corresponding native implementation (member or
free function) is unavailable. A dotted line shows an adaptation that will
be used only if `executor_execute_blocking_category_t<Executor>` is
`non_blocking_execution_tag`.

<img style="width:80%;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABLEAAAFbCAYAAAAqWBwXAAAAAXNSR0IArs4c6QAAQABJREFUeAHsnQncFdMbx5/2fRVSaJOKKEWokOy7Ivu+RmSPpKRsyb4vRdbKUn8kIUmIQmgjVEo72vdt/ud3/v8z5t537r0z973LzNzf+Xze985y5izfOTPznOc85zklLMt6UxhIgARIgARIgARIgARIgARIgARIgARIgARIILgElpdQSiwruOVjyUiABEiABEiABEiABEiABEiABEiABEiABEhAFpYkBBIgARIgARIgARIgARIgARIgARIgARIgARIIOgEqsYJ+h1g+EiABEiABEiABEiABEiABEiABEiABEiABoRKLjYAESIAESIAESIAESIAESIAESIAESIAESCDwBEoHvoQsIAl4IDBv3jxp2rSpbNy40UNsRskUgYoVK8rs2bOldu3amUqS6ZAACZAACZBA1gksXLhQGjduLBs2bMh6XswgugQqVaokf/zxh9SqVSu6lWTNSCBNAkcccYSMGzcuzat5GQn8j8CQIUPkwgsvjMFBJVYMDu6ElcDy5cu1Auvxxx+nQiVHN3H+/Ply8803y8qVK8k8R8yZDQmQAAmQQGYIrFixQiuwHnnkEalbt25mEmUqBUVg7ty5cuutt8qqVauoxCqoO8/KeiWwaNEiOeOMM+T000/3egnjkUAMgWuvvVYWL14ccww7VGIVQcIDYSZw/PHHS6NGjcJchdCUfdq0aaEpKwtKAiRAAiRAAm4Ejj32WG3J7XaOx0ggGYEffvhBK7GSxeE5Eih0As2bN5cuXboUOgbWP00CPXv2dL2SPrFcsfAgCZAACZAACZAACZAACZAACZAACZAACZBAkAhQiRWku8GykAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJuBKgEssVCw+SAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAkEiQCVWEG6GywLCZAACZAACZAACZAACZAACZAACZAACZCAKwEqsVyx8CAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkECQCFCJFaS7wbKQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAm4EqASyxULD5IACZAACZAACZAACZAACZAACZAACZAACQSJAJVYQbobLAsJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkIArASqxXLHwIAmQ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J2DaUsirweKTQMYJ4Nno06eP/st44kywYAi4vWNLWCoUDAFWNJIE1q5dK7///rsMHz5c5s+fL0uWLJGFCxfK4sWLZfXq1Xad8QBs27ZNypUrJ0888YRUr17dPpevjZUrV8pVV10lJUuWlOeee04qV66cr6LE5As+X3zxhT5mXhxgZ0LFihVlxx13lN13313at28vDRs2tP9wDPVhIAESIAESIIGgEoD4O3r0aFm/fn3SIuLbd//998vUqVMlHZH54osvluOOOy5pHkE8GVT5xC+rzZs3S69evWTevHm+Li1RooTsueee0qVLF9l3330TXgu5LYz3N2GFeIIEMkjgxx9/lN9++y2DKUY7qaeeeko+//xzueSSS+TYY4+NdmU91g7v4iOOOEJq1KjhvGIhlVhOHNwODYEJEyZIjx499Itx+fLldrnLli0r27dvl61bt9rH4jcGDRokl156afzhvOz37t1bC8fIvF+/ftKzZ8+8lCM+UwivTZo0kb///lvzjD+fbL9Tp04yYsSIZFF4jgRIgARIgARCRWDVqlUyZswYee+992TUqFF6kKxMmTKyZcsW13pgMOeKK66QZ555xvV80A8GVT5JhxsGN1u3bi3Lli1zlQ/NfcQgJzqOnTt3lhNPPFFq1qyZTna8hgRIgAR8E0D/dYcddhD0wSpVqqQNNGrXru07nQK5gEqsArnRkavm999/L3feeadAww+rKwQIjJjahlE3t4Bzhx56qHz66adup3N+bMOGDYKXk7EWq1Wrlq4LFHFBCBDW3UYXoRGHwGc4Q+jba6+9ZP/999ejlcccc4w0btw4CFVgGUiABEiABEgg4wTQ2fj666/l/fffl0cffVQ2bdqkZRAcR4C8cdhhh8lHH30kxpo544XIYoJBl0/SqfrMmTPlwAMP1JZ35j6ZdPbZZx+599575cgjj5Ty5cubw/wlARIggZwR+Oqrr/TsFmSIb8jpp58uQ4cOzVn+IctoIef8hOyOsbj/I4ARNYyELliwQDCdcPLkyQILq2uuuUY6duzoOp0NipeXXnopMAiHDBmiy24K9M8//8gbb7xhdvP+i9FImLPiReoMmE4BQe+dd97RlnAQdqdMmSLPP/+85k8FlpMWt0mABEiABKJGAEqQOXPmaKssKLAQjGIE30xMsYdFchgVWKhL0OUTlNFvwGAblI4YiDMBciEG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lpMESIAESIAESIAESIAESIAESIAESCDSBKjESn57qcRKzodnSYAESIAESIAESIAESIAESIAESIAESCAnBBYvXiyVK1fWfznJMGSZUIkVshvG4pIACZAACZAACZAACZAACZAACZAACUSTAJRYu+yySzQrl4Falc5AGkyCBEiABEiABEiABEiABEiABEJNYNu2bWL+tm7dam/j2A477CClSpUKdf1YeBIggXAQoBIr+X0KhRILH4yhQ4fqv+TVKdyz559/ft4rbz7s7dq1y3tZWIDCIGDaXBBqi7IMHz5c3nzzzSAUJ7BlqFSpUmDLxoIlJ4A2/uKLL+q/5DF5NugETj/99MAUEe1q2bJlUqJEicCUiQUhgTAQCJIMZHihTOeee67+M8f4G20CQWyHUSAOn1h06p74TpawVEh8OhhnZs+eLVOmTMlbYbZv3y49evSQ+fPny6233iqtW7fOW1kSZdymTRupV69eotM5O/7xxx/LqlWrspbf0qVLBX///POP/sPyo3/99Zf+w/bGjRvtvCEQ48WK0TM088svv1yOOuoo+3wQNlauXClXXXWVlCxZUp577rlAzntesGCB3HLLLZpj6dKlNUswdQZwrlq1qlSvXl2PVNasWVNvY//AAw+UKlWqOKNnZBt5HHHEERlJKxOJzJ07V7777rtMJJXxNLZs2SIXXnih4F324IMPyq677prxPLwmWLduXWnbtq3X6IwXIAK//fab/PjjjwEqUfGLAqXz22+/LYcddph069at+AmGJAXIMQ0bNgxEaVevXi2ffPKJfj8FokCqEJs2bZIxY8bIl19+KfPmzfNVLHwn+/fvL40aNfJ1XdAih0E+8cts/fr10rNnT4GFg5/QuHFjOeSQQ+TQQw+VihUr+rk0a3EhNx577LEStIEhPDN++WYNUh4S/uabb+Thhx+WBg0ayP333x955XyZMmXkhBNOEPwyZJYAZGX07x999NHMJhyN1BaGwhILgkA+hYFnnnlG/vzzT60QgQKlS5cu0bj9WajF0UcfnYVU/5ckNNJ+5gZDcQVTcAiUhx9+uDz//PNZK1u6Cffu3Vt/4FBW1A/CVRBDuXLldAcPPN0ClForVqzQf1DmmABFIhSHQRr1N2XL9C8EFvwFMUC5jHsHZSM67RMnToy8YBXE+xD2MqEjh7+ohJkzZ8rIkSN1daZPn67fU7QG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N2/OZZZZywtKrK1bt2pFVtYyYcKhITB58mT5+++/Bf6sGdIjQCWWCzcosYI0lRAv8P79++u54/R35XLDeIgEQkDgnnvu0U6l77///kAJZWZ6lZluFQKULCIJ+CYASyzT1n1fHIALIOz27t1byyYjR44MQIlYBBIgARLILoERI0bowYe+ffvKP//8k93Mspy6sQKmc/csgw5J8phKiCn/WCmYIU0CamWtmDBx4kRLmdxbKjn+FQgD5Yw6pg1kcmfBggVWhQoV2JYKpC1l672hfCZYf/31VyabZkxa9957L9so26hrG3jkkUdi2komdxo1auSaZ7aeI6ZLuSaTbUA5pLWmTp2ayUfCTmvQoEF8NvhOZhv4fxtQU/0ttWiD/XxkeuOAAw4gaz5vkW8D5cuXt9SCJ5l+fNJKr3Xr1tZVV12V1rW8SBNYUMQnFqa7wHxz6NChnLOrpL2gBHW7JBv+arAyAlYzylZYsWKFYPqD6ghK3bp1s5UN040wAYxa3XrrrbJq1SqpVatWVmq6cOFCbel41113ZSV9Z6LZepadeXA7MwR69uyZ1WmWaHfdunXTqzRlpsRMJcoEguRLBas9XnLJJaIGF7KCHNOb69SpI48++mhW0meiJBAmAldffXVWv0V43rA4zQknnBBILEF69wUSEAuVksCSJUuke/fusnz58ry7DFq8eLFMmTJFYGHIkD6BIkosk9Tpp58upUsnPG2i8TfkBFavXp1VJZbBc+yxx4qy+DK7/CUBzwR++OEHrcTyfEGaEXfccUfp0qVLmlfzsigSyPb0bQxMtGnThu0uio0n4nVCRyDbAYvr8J2cbcpMPwwEbr755qwXs2XLlnzesk6ZGeSLAFwKBCXAJUDFihXlyCOPDEqRQlkO+sQK5W1joUmABEiABEiABEiABEiABEiABEiABMJCAL7e4NBdTW8MS5EDWU4qsQJ5W1goEiABEiABEiABEiABEiABEiABEiCBKBDAAgWff/65nHbaaVGoTl7rQCVWXvEzcxIgARIgARIgARIgARIgARIgARIggSgTeO+997TPcVhiMRSPAJVYxePHq0mABEiABEiABEiABEiABEiABEiABEggIYF33nlHjj76aIHPR4biEaASq3j8eDUJkAAJkAAJkAAJkAAJkAAJkAAJkAAJuBJYuXKljB07llMJXen4P0glln9mvIIE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tGljo0aNso8++sg6duxovXr1StnQKk8ilBoCySEg21ddunSx1atXewFWu3btkpM5cpIXAgix8oKRSCAAAQhAAAIQgAAEIACBciKgl+NHH33Upk2bZtLS2muvvUw2tD788MNywkBZIZAYAq+88or9/ve/ty233NImT55sm266aWLyRkbyRwAhVv5YEhMEIAABCEAAAhCAAAQgUGYEdtttN29zZ/z48TZ//nzbaaed7IwzzjAtacJBAAJ1Q0AC5R49elj37t1twoQJ1qpVq7pJmFTqnABCrDpHToIQgAAEIAABCEAAAhCAQKkR0Av09OnT7b777vMv0VtvvbUNHjzYtEMaDgIQKAyBIAjs8ssvtz59+thZZ51lo0ePtmbNmhUmMWJNBAF2J0xENZAJCEAAAhCAAAQgAAEIQKBUCKxcudJuvfVWGzp0qDVo0MAuvfRS69evnzVt2rRUikg5IFDvBJYvX24nnniiPfvss3bbbbd5Dch6zxQZKDSBhQixCo2Y+CEAAQhAAAIQgAAEIACBsiTw3Xff2bBhw+yWW26xjTbayK699lo77rjjvGCrLIFQaAjkicDcuXO9DbrFixf7HUJlCwtXFgQWspywLOqZQkIAAhCAAAQgAAEIQAACdU2gZcuWdv3119ucOXNs77339lojnTp18ja06jovpAeBUiEgzSv1o0aNGtnbb7/tjbmXStkoR24CCLFyM8IHBCAAAQhAAAIQgAAEIACBGhPQLmmylTVr1iyvkSXj07KhNXPmzBrHSUAIlBuBVatWeTtzPXv2NP1NmTLFNt9883LDUPblRYhV9k0AABCAAAQgAAEIQAACEIBAXRDYYYcd7JlnnrFXXnnFtNSwY8eOXjtr3rx5dZE8aUCgaAlo2WC3bt1s5MiRds8999j9999va665ZtGWh4zXnABCrJqzIyQEIAABCEAAAhCAAAQgAIHYBLS08M033/Q7qU2dOtW23XZb+8tf/mJLly6NHRcBIFDqBLR8cOedd7YFCxaY+stpp51W6kWmfNUQQIhVDRxuQQACEIAABCAAAQhAAAIQKBSBo48+2j788EMbMWKEPfzww9auXTu77rrrbMWKFYVKknghUDQE1A/OPvtsO/TQQ/3y2+nTp3thVtEUgIwWhAC7ExYEK5FCAAIQgAAEIAABCEAAAhCITmD58uU2fPhwL9CSQfirr77a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BAL1TIDlhPVcASQPAQhAAAIQgAAEIAABCJQXAQluBgwY4AU0++23n22yySZ2xRVXZEC44YYbvHDrp59+yrh+7LHH2mGHHZZxraYnEigdfPDBtuOOO9qsWbNiRfOPf/zD508COAnWXn/99dS5rh166KEV4pMfCba6detmXbt29UKsUNASev7111+tf//+1qpVK5MNr5122skLcl566aXQiynfSuOBBx7wNr622247O/DAA61du3YmbjV177zzjo9D8SmPG2ywgZ122mmWXgcSEEm4JW7pyyMfe+wxL3C89dZbU8lHKUvoWX6HDBnihXIq89577+3zMnjw4NCLL5vKnZ4f3cxuE7vvvrvnM3DgQB/2mGOOyaib8ePHp+KMk8dUIA4gUI8EEGLVI3yShgAEIAABCEAAAhCAAATKj8Dtt99uTz31lP3rX//yWj89e/a0q6++2qZNm1ZnMKSB9cc//tFrRT3xxBPV2rSqLFMyEP/uu+/6v0033dT22GOP1LmuP/nkkxWCHXXUUdavXz8v9Lruuuvso48+suHDh2f4u+iii+yuu+6y0aNHm/IojStpVx1xxBEV7HldcsklPg5xmzp1qhd4XXbZZSkNsYyIc5xI80qCI2l9yXbY8uXL7d5777X777/frrzyylToPffc09fV5MmT7cYbb/TXpZGmcu22226pa7oRpywSal566aV2/PHHm5ZnSntKwibZOYvrJk2a5OtCQjG5hx56KKNuunfvnooyTh5TgTiAQH0ScOqSOAhAAAIQgAAEIAABCEAAAhCIScAJngKnGRM5lFtyF7h3v8AJZQKngZQK5wQW/vq5556buuaMtftrTpiSuqYDJywKdt5554xr4clf//pXH8YJkcJLGb9OQBPsu+++gRMOBT169AjWWGON4LnnnsvwU5MTpwHl46sqbFiWUaNGpbw4LabALXHz+QkvionTUgucQCe85H8/+OADXy4n+PLnIUexd0suU35Hjhzp/b3yyiupa1EPzjvvPM/j66+/zghy9NFHB2uttVbgluelrivvBxxwgM/re++9Fxx55JGBM7AfuOWEKT9Ry6IATpgXNGzYMOjdu3cqfGUHIceobeLBBx/0PN54443KovNtMArvSgNXcnHzzTcPnFCykjtcgkDeCCzAJlZ9ShBJGwIQgAAEIAABCEAAAhAoOwJOMOKXqoUFl+0jLV2bO3dueKlgvytXrjRpRElbZ+zYseaEMQVLKztiLc0Lnex8aWmc7H6FTsv5lD/Zy3r++efDy37ZnvzLVlS6kwablh2Gbvvtt/eHNdn9UXa6pFGWrQ0n215avqclk9IIk1NepN20yy67+GWH2vFRywm32morf1//4pRFaWtp4plnnpkKXxcHcfJYF/khDQhEIYAQKwol/EAAAhCAAAQgAAEIQAACECggAacV5W09FTAJH7XsSUnII8PesiFVny7dYL3yod305EaMGGGNG2e+qjpNpwwbVN5j1r/s+LJuV3uqtLUssE+fPhX8tWzZsoIdKhl8l1Du2muv9csYe/XqlREuTllkZ0suFJJlRFTAkzh5LGA2iBoCsQhkPhliBcUzBCAAAQhAAAIQgAAEIAABCNSWgIxrS6AgY+HZTrvMpTu3KCf9NPaxBDJ///vfrUuXLibbSLLtlL0zYuxIXYDa5ktphvmQLSe3tLIm2ahxGKUd1kO2AK2ySGW3SjaxZORdNsB0LLtWoYtTFhn2l1MbSNfmCuPK/o3bJqqqmzh5zM4D5xCoLwIYdq8v8qQLAQhAAAIQgAAEIAABCEDAEdBSNAlQtBtf6H7zm9/4w5kzZ4aX/BK7t956K3Ve0wPtEPjMM894zSNnG8trZtU0LoVTXrUM7z//+U9tovEaTRIgaaleXbuOHTt6HjK2n8t99913Js0rLQGVEFDLQy+++GJ7+eWXU0G1w2DUsnTq1MmHk0H76lzcNhH6166Qlbk4eawsPNcgUB8E0MSqD+qkCQEIQAACEIAABCAAAQiULQHZQHr66ae9EOTNN9807ai33377eVtVIZSuXbv6Q+3AN2jQIL8Ln/xtuOGGoRf/q6Vos2bN8sehwOvFF1/0u/ppiWJl2l3yLMHJo48+6nf9O/TQQ23ChAnmDJj7eOL+c8biTeU44YQT/O56smm1ZMkSO+aYY2JFJdtgWqInYY7idIbOTbsBLlu2zNvDOuSQQ1LaWrEijuBZjB944AE79dRTvVBKdsOktSZbWL/88kuqbqTVdNJJJ9m8efNs4sSJpmWOyq8znu7LO336dG9bK05ZtAOhyvrII4/4HRmPPfZYH692b1xzzTWtb9++vgRR20RYXO2WuM4669jNN9/sNeWkfSf7XRJeyR5ZnDyGcfILgXon4DohDgIQgAAEIAABCEAAAhCAAARiEoi7O6EThgSnnHJKsNFGG2lNoP9zS8kC7TrnbFVVSH3gwIF+1zr5dTaYAqexFZx88skZuxNqx78wruxfJ/DKiDPcnTD9YrijoRN2BU6TKv1W5GPtlucEO0GTJk1SeXGCmVT4OLvqKQ9XXnll0KZNm1RcKpdb+hbMnj3bxxnuTpi9i+ELL7zgw4wZMyaVdpwDt0QwcIKijHJo975zzjknFc3QoUN9GqqbdPfSSy8FziZXoHJr90e5KGUJ41CYK664IlCdhfWoHQ9vvfXW0Iv/jdIm0gM8++yzgVuimIqzUaNGgROgprzEyWMqUBUH7E5YBRgu55PAggaKzXUSHAQgAAEIQAACEIAABCAAAQjEIHDNNdfYww8/XGHXvChRyMC6EyB4jZvq/Mvf4sWLvdZMFFtN1cVV6Huy1SRNHyf4sdatW9c6uW+++ca+//57H5c0nurKaWnn559/7rWgnDDNnHCu1knHKYs0z6T9td5661nDhhUtANWkTYijEzZ6lqqfylycPFYWXobpncAvwzZYZf64BoFaEFjIcsJa0CMoBCAAAQhAAAIQgAAEIACBmhDQMjH95XLy07Zt21zeEnHfafnkdbmfBEj6q2snYWG+d26MU5ZcAruatIkWLVqY/qpzcfJYXTzcg0AhCSDEKiRd4oYABCAAAQhAAAIQgAAEIFAkBJ5//nl77rnncuZWO+j1798/p7/69iCtoChO/tq3bx/FK34gAIF6JoAQq54rgOQhAAEIQAACEIAABCAAAQgkgcDXX3/tDcjnykvSlzWG+Zdh9CjO2diK4g0/EIBAAgggxEpAJZAFCEAAAhCAAAQgAAEIQAAC9U1Au+7pr1ScdmnEQQACpUWgopW40iofpYEABCAAAQhAAAIQgAAEIAABCEAAAhAoAQIIsUqgEikCBCAAAQhAAAIQgAAEIAABCEAAAhAodQIIsUq9hikfBCAAAQhAAAIQgAAEIAABCEAAAhAoAQIIsUqgEikCBCAAAQhAAAIQgAAEIAABCEAAAhAodQIIsUq9hikfBCAAAQhAAAIQgAAEIAABCEAAAhAoAQIIsUqgEikCBCAAAQhAAAIQgAAEIAABCEAAAhAodQIIsUq9hikfBCAAAQhAAAIQgAAEIAABCEAAAhAoAQIIsUqgEikCBCAAAQhAAAIQgAAEIAABCEAAAhAodQIIsUq9hikfBCAAAQhAAAIQgAAEIAABCEAAAhAoAQIIsUqgEikCBCAAAQhAAAIQgAAEIAABCEAAAhAodQIIsUq9hikfBCAAAQhAAAIQgAAEIAABCEAAAhAoAQIIsUqgEikCBCAAAQhAAAIQgAAEIAABCEAAAhAodQIIsUq9hikfBCAAAQhAAAIQgAAEIAABCEAAAhAoAQIIsUqgEikCBCAAAQhAAAIQgAAEIAABCEAAAhAodQKNS72AlA8CEIAABCAAAQhAAAIQgEAhCDRq1Mhmz55tDRo0KET0xAmBoiPQuDEihqKrtCLLcIPAuSLLM9mFAAQgAAEIQAACEIAABCBQ7wSWLFliL7/8svFKVe9VQQYSQEDC3G7dulnLli0TkBuyUKIEFiLEKtGapVgQgAAEIAABCEAAAhCAAAQgAAEIQKCECCzEJlYJ1SZFgQAEIAABCEAAAhCAAAQgAAEIQAACpUoAIVap1izlggAEIAABCEAAAhCAAAQgAAEIQAACJUQAIVYJVSZFgQAEIAABCEAAAhCAAAQgAAEIQAACpUrg/wGh8po+MsBugwAAAABJRU5ErkJggg==">

## Executor type traits

In order to help programmers define their own ad hoc requirements for executor
types, our design provides a set of executor type traits for introspecting the
properties of executors at compile time. These fine-grained type traits detect
characteristics such as native support for execution functions as well as
compatibility between an executor type and an executor customization point.

For example, for an execution function such as `execute`, the executor supports
the following traits:

* `has_execute_member<X>` and `has_execute_member_v<X>`, to detect the presence
of a member named `execute` that satisfies the corresponding syntactic
requirements.
* `has_execute_free_function<X>` and `has_execute_free_function_v<X>`, to
detect the presence of a free function named `execute`, accepting the
executor as the initial parameter, and that satisfies the corresponding
syntactic requirements.
* `can_execute<X>` and `can_execute_v<X>`, to determine whether the
corresponding customization point is well-formed for the executor.

Programmers may employ these type traits at software boundaries to define
requirements for executor composition as well as reject types of executors
which are known to be incompatible.

These traits may also be used to determine which implementation strategy will
be used by a customization point. That is, whether the customization support
can use native support (via member or free function) or an adaptation. If a
particular customization point's adaptation is inefficient when implementing
some higher level algorithm, the trait may be used to select an alternative
algorithm implementation not based on that customization point.

While these traits are not strictly required by this proposal -- we may employ
SFINAE to detect the presence of members or free functions -- correctly
detecting adherence to the syntactic requirements is complex. Therefore these
traits are included to simplify feature detection for programmers, as well as
reducing the verbosity of this proposal's wording.

## Executor Categories

Our design organizes executors into *executor
categories* based on how they are expected to be used by software components
composing with them. These categories correspond to the application domains
served by the C++ Standard Library and the Parallelism, Concurrency, and
Networking Technical Specifications. The requirements for membership in an
executor category include basic requirements on executor types as well as
requirements based on their compatibility with customization points. For
example, the executor category `TwoWayExecutor` includes all executors
compatible with the two-way, single-agent executor customization points such as
`execution::async_execute()`. Executor categories are not necessarily mutually exclusive,
  and one executor type may be a member of multiple categories if the
  requirements for those categories admit mutual membership.

This proposal defines four named categories: `OneWayExecutor`,
     `TwoWayExecutor`, `BulkTwoWayExecutor`, and `NonblockingOneWayExecutor`.
     `OneWayExecutor` and `TwoWayExecutor` summarize the requirements for basic
     executors which create single-agent execution with minimal guarantees.
     `OneWayExecutor`s do not provide a channel for synchronizing with the
     completion of execution, while `TwoWayExecutor`s do provide such a
     channel. `BulkTwoWayExecutor` summarizes requirements for executors which
     create bulk-agent execution and also provide a channel for
     synchronization. This category summarizes the requirements for executors
     which can compose with parallel algorithms.  Finally,
     `NonblockingOneWayExecutor` extends `OneWayExecutor`'s requirements by
     demanding that an executor's execution functions do not block the
     calling thread of those operations. This additional requirement on
     blocking behavior is critical to the needs of the Networking TS.

We have not attempted to completely capture every kind of interesting
collection of executors in our categorization. By design, our categorization of
executors is incomplete to accommodate future extension. Moreover, we recognize
that the particular categories we define may not precisely match the
requirements of all existing software interfaces which need to compose with
executors. For example, the regularity of our design suggests the existence of
a hypothetical executor category named
`NonblockingHostBasedBulkTwoWayExecutor`. Such a category would correspond to
executor types which create bulk, two-way execution hosted on a thread, and
would create execution in a way that is guaranteed not to block the calling
thread. However, our proposal does not define such a category. Instead, this
category could be created by composing the executor type traits described above.


## Execution Contexts

In our design, *execution contexts* are objects that represent a specific
collection of resources and may be used by executor to create execution. For
example, a thread pool is an execution context which manages a collection of
threads upon which an associated executor may create execution agents. For our
purposes of defining a programming model for executors, the only salient
expectation for execution contexts is the ability to obtain an executor from
them. However, we have chosen not to prescribe a required interface for doing
so. Instead, we have defined very basic requirements for execution contexts
which allow almost any type of object to be an execution context. Our
requirements for execution contexts are deliberately minimal and intended to
provide a standard protocol for obtaining an executor's context and reason
about its identity in generic code. Yet, these minimal requirements still allow
for further refinement in future libraries. For example, we illustrate
requirements for a `NetworkingExecutionContext` that we expect the Networking
TS to define which would enumerate expectations on execution contexts
compatible with networking use cases. This refinement's requirements
significantly strengthen our weak requirements in part by demanding that all
such contexts derive from a specific concrete class.

In order to evaluate this proposal, it will be useful to have at least one
concrete execution context readily available. Our proposal specifies a single
execution context, `static_thread_pool`, which abstracts a explicitly-sized
collection of threads and implements an effectively unbounded work queue. This
thread pool type provides functions for typical thread pool operations as well
as an `.executor()` function for obtaining an executor associated with the
thread pool. We recognize that different types of thread pools are suited to
different use cases and emphasize that this proposal's `static_thread_pool`
represents a single design in this space which is not intended as definitive.

## Extensibility

This proposal is intended to provide a foundation for future enhancements to
executors and execution in general in C++. Naturally, it is incomplete and we
anticipate extension. Here, we discuss briefly our vision for how the major
components of our overall design can be extended by future follow-on proposals.

**`Future` concept.** One immediate concern is the conceptualization of
`std::future`-like types. We anticipate that some types of executors will
expose idiosyncratic, custom, and non-standard future types to represent
asynchronous tasks due to requirements of underlying execution resources. An
elaboration of the requirements of a hypothetical `Future` concept is needed.

**Execution resources.** Our proposal is silent about how a program might
enumerate and represent the available execution resources present in the
system. A future proposal describing a means of representing system resources
with standard execution contexts and obtaining executors from them would
provide programmers concerned with performance the tools to reason about
locality.

**Execution contexts.** This paper proposes a single concrete execution
context, `static_thread_pool`, which embodies one approach for representing a
thread pool. There are other approaches to thread pools with different features
and limitations which others could propose. For example, a hypothetical
`dynamic_thread_pool` type could automatically change its thread count to adapt
to the state of the system, with the goal of guaranteeing concurrent execution.
Another possible execution context could emulate the existing behavior of
`std::async()` to aid in migration from the standard library's existing
features for concurrency and parallelism to this new model of executors. Such a
context would allow programmers to introduce executors without breaking any
assumed semantics of `std::async()`, such as concurrent execution agents,
thread-per-request, and future blocking behavior.

Besides introducing concrete execution context types, future proposals could
refine our `ExecutionContext` concept by introducing concepts with additional
requirements. As an example, a parallel execution framework might define
requirements for a hypothetical `IntrospectableExecutionContext` which would
require contexts to provide functionality for resource introspection. Generic
code could depend on such functionality to query the number of hardware threads
associated with execution context. These and other extensions to our basic
model of execution contexts may be explored as future proposals.

**Executor categories.** Future proposals might expand our executor
categorization to additional application domains if the categorizations
proposed here are insufficient for representing their requirements. For
example, our proposal does not directly address issues related to heterogeneous
execution resources. These issues can be addressed in the future with new kinds
of executors incorporated into the overall framework with the appropriate
categorization.

## Changelog

### Changes since R0

* Executor category simplification
* Specified executor customization points in detail
* Introduced new fine-grained executor type traits
    * Detectors for execution functions
    * Traits for introspecting cross-cutting concerns
        * Introspection of mapping of agents to threads
        * Introspection of execution function blocking behavior
* Allocator support for single agent execution functions
* Renamed `thread_pool` to `static_thread_pool`
* New introduction

# Proposed Wording

### Header `<execution>` synopsis

```
namespace std {
namespace experimental {
inline namespace concurrency_v2 {
namespace execution {

  // Member detection type traits:

  template<class T> struct has_execute_member;
  template<class T> struct has_post_member;
  template<class T> struct has_defer_member;
  template<class T> struct has_sync_execute_member;
  template<class T> struct has_async_execute_member;
  template<class T> struct has_async_post_member;
  template<class T> struct has_async_defer_member;
  template<class T> struct has_then_execute_member;
  template<class T> struct has_bulk_execute_member;
  template<class T> struct has_bulk_post_member;
  template<class T> struct has_bulk_defer_member;
  template<class T> struct has_bulk_sync_execute_member;
  template<class T> struct has_bulk_async_execute_member;
  template<class T> struct has_bulk_async_post_member;
  template<class T> struct has_bulk_async_defer_member;
  template<class T> struct has_bulk_then_execute_member;

  template<class T> constexpr bool has_execute_member_v = has_execute_member<T>::value;
  template<class T> constexpr bool has_post_member_v = has_post_member<T>::value;
  template<class T> constexpr bool has_defer_member_v = has_defer_member<T>::value;
  template<class T> constexpr bool has_sync_execute_member_v = has_sync_execute_member<T>::value;
  template<class T> constexpr bool has_async_execute_member_v = has_async_execute_member<T>::value;
  template<class T> constexpr bool has_async_post_member_v = has_async_post_member<T>::value;
  template<class T> constexpr bool has_async_defer_member_v = has_async_defer_member<T>::value;
  template<class T> constexpr bool has_then_execute_member_v = has_then_execute_member<T>::value;
  template<class T> constexpr bool has_bulk_execute_member_v = has_bulk_execute_member<T>::value;
  template<class T> constexpr bool has_bulk_post_member_v = has_bulk_post_member<T>::value;
  template<class T> constexpr bool has_bulk_defer_member_v = has_bulk_defer_member<T>::value;
  template<class T> constexpr bool has_bulk_sync_execute_member_v = has_bulk_sync_execute_member<T>::value;
  template<class T> constexpr bool has_bulk_async_execute_member_v = has_bulk_async_execute_member<T>::value;
  template<class T> constexpr bool has_bulk_async_post_member_v = has_bulk_async_post_member<T>::value;
  template<class T> constexpr bool has_bulk_async_defer_member_v = has_bulk_async_defer_member<T>::value;
  template<class T> constexpr bool has_bulk_then_execute_member_v = has_bulk_then_execute_member<T>::value;

  // Free function detection type traits:

  template<class T> struct has_execute_free_function;
  template<class T> struct has_post_free_function;
  template<class T> struct has_defer_free_function;
  template<class T> struct has_sync_execute_free_function;
  template<class T> struct has_async_execute_free_function;
  template<class T> struct has_async_post_free_function;
  template<class T> struct has_async_defer_free_function;
  template<class T> struct has_then_execute_free_function;
  template<class T> struct has_bulk_execute_free_function;
  template<class T> struct has_bulk_post_free_function;
  template<class T> struct has_bulk_defer_free_function;
  template<class T> struct has_bulk_sync_execute_free_function;
  template<class T> struct has_bulk_async_execute_free_function;
  template<class T> struct has_bulk_async_post_free_function;
  template<class T> struct has_bulk_async_defer_free_function;
  template<class T> struct has_bulk_then_execute_free_function;

  template<class T> constexpr bool has_execute_free_function_v = has_execute_free_function<T>::value;
  template<class T> constexpr bool has_post_free_function_v = has_post_free_function<T>::value;
  template<class T> constexpr bool has_defer_free_function_v = has_defer_free_function<T>::value;
  template<class T> constexpr bool has_sync_execute_free_function_v = has_sync_execute_free_function<T>::value;
  template<class T> constexpr bool has_async_execute_free_function_v = has_async_execute_free_function<T>::value;
  template<class T> constexpr bool has_async_post_free_function_v = has_async_post_free_function<T>::value;
  template<class T> constexpr bool has_async_defer_free_function_v = has_async_defer_free_function<T>::value;
  template<class T> constexpr bool has_then_execute_free_function_v = has_then_execute_free_function<T>::value;
  template<class T> constexpr bool has_bulk_execute_free_function_v = has_bulk_execute_free_function<T>::value;
  template<class T> constexpr bool has_bulk_post_free_function_v = has_bulk_post_free_function<T>::value;
  template<class T> constexpr bool has_bulk_defer_free_function_v = has_bulk_defer_free_function<T>::value;
  template<class T> constexpr bool has_bulk_sync_execute_free_function_v = has_bulk_sync_execute_free_function<T>::value;
  template<class T> constexpr bool has_bulk_async_execute_free_function_v = has_bulk_async_execute_free_function<T>::value;
  template<class T> constexpr bool has_bulk_async_post_free_function_v = has_bulk_async_post_free_function<T>::value;
  template<class T> constexpr bool has_bulk_async_defer_free_function_v = has_bulk_async_defer_free_function<T>::value;
  template<class T> constexpr bool has_bulk_then_execute_free_function_v = has_bulk_then_execute_free_function<T>::value;

  // Customization points:

  namespace {
    constexpr unspecified execute = unspecified;
    constexpr unspecified post = unspecified;
    constexpr unspecified defer = unspecified;
    constexpr unspecified sync_execute = unspecified;
    constexpr unspecified async_execute = unspecified;
    constexpr unspecified async_post = unspecified;
    constexpr unspecified async_defer = unspecified;
    constexpr unspecified then_execute = unspecified;
    constexpr unspecified bulk_execute = unspecified;
    constexpr unspecified bulk_post = unspecified;
    constexpr unspecified bulk_defer = unspecified;
    constexpr unspecified bulk_sync_execute = unspecified;
    constexpr unspecified bulk_async_execute = unspecified;
    constexpr unspecified bulk_async_post = unspecified;
    constexpr unspecified bulk_async_defer = unspecified;
    constexpr unspecified bulk_then_execute = unspecified;
  }

  // Customization point type traits:

  template<class T> struct can_execute;
  template<class T> struct can_post;
  template<class T> struct can_defer;
  template<class T> struct can_sync_execute;
  template<class T> struct can_async_execute;
  template<class T> struct can_async_post;
  template<class T> struct can_async_defer;
  template<class T> struct can_then_execute;
  template<class T> struct can_bulk_execute;
  template<class T> struct can_post_execute;
  template<class T> struct can_defer_execute;
  template<class T> struct can_bulk_sync_execute;
  template<class T> struct can_bulk_async_execute;
  template<class T> struct can_bulk_async_post;
  template<class T> struct can_bulk_async_defer;
  template<class T> struct can_bulk_then_execute;

  template<class T> constexpr bool can_execute_v = can_execute<T>::value;
  template<class T> constexpr bool can_post_v = can_post<T>::value;
  template<class T> constexpr bool can_defer_v = can_defer<T>::value;
  template<class T> constexpr bool can_sync_execute_v = can_sync_execute<T>::value;
  template<class T> constexpr bool can_async_execute_v = can_async_execute<T>::value;
  template<class T> constexpr bool can_async_post_v = can_async_post<T>::value;
  template<class T> constexpr bool can_async_defer_v = can_async_defer<T>::value;
  template<class T> constexpr bool can_then_execute_v = can_then_execute<T>::value;
  template<class T> constexpr bool can_bulk_execute_v = can_bulk_execute<T>::value;
  template<class T> constexpr bool can_bulk_post_v = can_bulk_post<T>::value;
  template<class T> constexpr bool can_bulk_defer_v = can_bulk_defer<T>::value;
  template<class T> constexpr bool can_bulk_sync_execute_v = can_bulk_sync_execute<T>::value;
  template<class T> constexpr bool can_bulk_async_execute_v = can_bulk_async_execute<T>::value;
  template<class T> constexpr bool can_bulk_async_post_v = can_bulk_async_post<T>::value;
  template<class T> constexpr bool can_bulk_async_defer_v = can_bulk_async_defer<T>::value;
  template<class T> constexpr bool can_bulk_then_execute_v = can_bulk_then_execute<T>::value;

  // Executor type traits:

  template<class T> struct is_one_way_executor;
  template<class T> struct is_non_blocking_one_way_executor;
  template<class T> struct is_two_way_executor;
  template<class T> struct is_bulk_two_way_executor;

  template<class T> constexpr bool is_one_way_executor_v = is_one_way_executor<T>::value;
  template<class T> constexpr bool is_non_blocking_one_way_executor_v = is_non_blocking_one_way_executor<T>::value;
  template<class T> constexpr bool is_two_way_executor_v = is_two_way_executor<T>::value;
  template<class T> constexpr bool is_bulk_two_way_executor_v = is_bulk_two_way_executor<T>::value;

  template<class Executor> struct executor_context;

  template<class Executor>
    using executor_context_t = typename executor_context<Executor>::type;

  template<class Executor, class T> struct executor_future;

  template<class Executor, class T>
    using executor_future_t = typename executor_future<Executor, T>::type;

  struct other_execution_mapping_tag {};
  struct thread_execution_mapping_tag {};
  struct unique_thread_execution_mapping_tag {};

  template<class Executor> struct executor_execution_mapping_category;

  template<class Executor>
    using executor_execution_mapping_category_t = typename executor_execution_mapping_catetory<Executor>::type;

  struct blocking_execution_tag {};
  struct possibly_blocking_execution_tag {};
  struct non_blocking_execution_tag {};

  template<class Executor> struct executor_execute_blocking_category;

  template<class Executor>
    using executor_execute_blocking_category_t = typename executor_execute_blocking_category<Executor>::type;

  // Bulk executor traits:

  struct sequenced_execution_tag {};
  struct parallel_execution_tag {};
  struct unsequenced_execution_tag {};

  template<class Executor> struct executor_execution_category;

  template<class Executor>
    using executor_execution_category_t = typename executor_execution_category<Executor>::type;

  template<class Executor> struct executor_shape;

  template<class Executor>
    using executor_shape_t = typename executor_shape<Executor>::type;

  template<class Executor> struct executor_index;

  template<class Executor>
    using executor_index_t = typename executor_index<Executor>::type;

  // Executor work guard:

  template <class Executor>
    class executor_work_guard;

  // Polymorphic executor wrappers:

  class one_way_executor;
  class non_blocking_one_way_executor;
  class two_way_executor;

} // namespace execution
} // inline namespace concurrency_v2
} // namespace experimental
} // namespace std
```

## Requirements

### Customization point objects

*(The following text has been adapted from the draft Ranges Technical Specification.)*

A *customization point object* is a function object (C++ Std, [function.objects]) with a literal class type that interacts with user-defined types while enforcing semantic requirements on that interaction.

The type of a customization point object shall satisfy the requirements of `CopyConstructible` (C++Std [copyconstructible]) and `Destructible` (C++Std [destructible]).

All instances of a specific customization point object type shall be equal.

Let `t` be a (possibly const) customization point object of type `T`, and `args...` be a parameter pack expansion of some parameter pack `Args...`. The customization point object `t` shall be callable as `t(args...)` when the types of `Args...` meet the requirements specified in that customization point object's definition. Otherwise, `T` shall not have a function call operator that participates in overload resolution.

Each customization point object type constrains its return type to satisfy some particular type requirements.

The library defines several named customization point objects. In every translation unit where such a name is defined, it shall refer to the same instance of the customization point object.

[*Note:* Many of the customization points objects in the library evaluate function call expressions with an unqualified name which results in a call to a user-defined function found by argument dependent name lookup (C++Std [basic.lookup.argdep]). To preclude such an expression resulting in a call to unconstrained functions with the same name in namespace `std`, customization point objects specify that lookup for these expressions is performed in a context that includes deleted overloads matching the signatures of overloads defined in namespace `std`. When the deleted overloads are viable, user-defined overloads must be more specialized (C++Std [temp.func.order]) to be used by a customization point object. *--end note*]

### `Future` requirements

A type `F` meets the `Future` requirements for some value type `T` if `F` is `std::experimental::future<T>` (defined in the C++ Concurrency TS, ISO/IEC TS 19571:2016).  [*Note:* This concept is included as a placeholder to be elaborated, with the expectation that the elaborated requirements for `Future` will expand the applicability of some executor customization points. *--end note*]

### `ProtoAllocator` requirements

A type `A` meets the `ProtoAllocator` requirements if `A` is `CopyConstructible` (C++Std [copyconstructible]), `Destructible` (C++Std [destructible]), and `allocator_traits<A>::rebind_alloc<U>` meets the allocator requirements (C++Std [allocator.requirements]), where `U` is an object type. [*Note:* For example, `std::allocator<void>` meets the proto-allocator requirements but not the allocator requirements. *--end note*] No comparison operator, copy operation, move operation, or swap operation on these types shall exit via an exception.

### `ExecutionContext` requirements

A type meets the `ExecutionContext` requirements if it satisfies the `EqualityComparable` requirements (C++Std [equalitycomparable]). No comparison operator on these types shall exit via an exception.

### Requirements on execution functions

An execution function is a member function of the form:

    x.e(...)

or a free function of the form:

    e(x, ...)

where `x` denotes an executor object, `e` denotes the function name and `...` denotes the parameters.

Each execution function is made up from a combination of three properties: its **blocking semantics**, **directionality**, and **cardinality**. The combination of these properties determines the execution function's name, parameters, and semantics.

#### Naming of execution functions

The name of an execution function is determined by the combination of its properties. A word or prefix is associated with each property, and these are concatenated in the order below.

| Cardinality | Directionality | Blocking semantics |
|-------------|----------------|--------------------|
| `""` or `"bulk_"` | `""` or `"sync_"` or `"async_"` or `"then_"` | `"execute"` or `"post"` or `"defer"` |

#### Semantics of execution functions

The parameters of the execution function and semantics that apply to the the execution function and to the execution agents created by it are determined by the combination of its properties. Parameters and semantics are added to an execution function for each of the properties. Whenever there is a conflict of semantics the presedence is resolved in the order below.

    Cardinality > Directionality > Blocking semantics

#### Blocking semantics

The blocking semantics of an execution function may be one of the following:

* *Potentially blocking:* The execution function may block the caller pending completion of the submitted function objects. Execution functions having potentially blocking semantics are named `execute`.
* *Non-blocking:* The execution function shall not block the caller pending completion of the submitted function objects. Execution functions having non-blocking semantics are named `post` or `defer`.

##### Requirements on execution functions having potentially blocking semantics

In the Table below, `x` denotes a (possibly const) executor object of type `X` and `f` denotes a function object of type `F&&` callable as `DECAY_COPY(std::forward<F>(f))()` and where `decay_t<F>` satisfies the `MoveConstructible` requirements.

| Expression | Return Type | Operational semantics |
|------------|-------------|---------------------- |
| `x.execute(f, ...)` <br/> `execute(x, f, ...)` | void | Creates an execution agent with forward progress guarantees of `executor_execution_mapping_category_t<X>` which invokes `DECAY_COPY( std::forward<F>(f))()` at most once, with the call to `DECAY_COPY` being evaluated in the thread that called `execute`. <br/> <br/> May block forward progress of the caller until `DECAY_COPY( std::forward<F>(f))()` finishes execution. <br/> <br/> The invocation of `execute` synchronizes with (C++Std [intro.multithread]) the invocation of `f`. |

##### Requirements on execution functions having non-blocking semantics

In the Table below, `x` denotes a (possibly const) executor object of type `X` and `f` denotes a function object of type `F&&` callable as `DECAY_COPY(std::forward<F>(f))()` and where `decay_t<F>` satisfies the `MoveConstructible` requirements.

| Expression | Return Type | Operational semantics |
|------------|-------------|---------------------- |
| `x.post(f, ...)` <br/>`post(x, f, ...)` | void | Creates an execution agent with forward progress guarantees of `executor_execution_mapping_category_t<X>` which invokes `DECAY_COPY( std::forward<F>(f))()` at most once, with the call to `DECAY_COPY` being evaluated in the thread that called `post`. <br/> <br/> Shall not block forward progress of the caller until `DECAY_COPY( std::forward<F>(f))()` finishes execution. <br/> <br/> The invocation of `execute` synchronizes with (C++Std [intro.multithread]) the invocation of `f`. |
| `x.defer(f, ...)` <br/>`defer(x, f, ...)` | void | Creates an execution agent with forward progress guarantees of `executor_execution_mapping_category_t<X>` invokes `DECAY_COPY( std::forward<F>(f))()` at most once, with the call to `DECAY_COPY` being evaluated in the thread that called `defer`. <br/> <br/> Shall not block forward progress of the caller until `DECAY_COPY( std::forward<F>(f))()` finishes execution. <br/> <br/> The invocation of `execute` synchronizes with (C++Std [intro.multithread]) the invocation of `f`. |

#### Directionality

The directionality property of an execution function may be one of the following:

* *One-way:* The execution function creates execution agents without a channel for awaiting the completion of a submitted function object or for obtaining its result. *Note:* That is, the executor provides fire-and-forget semantics. *--end note*] The names of execution functions having one-way directionality do not have an associated prefix.
* *Synchronous two-way:* The execution function blocks until execution of the submitted function is complete, and returns the result. The names of execution functions having synchronous two-way directionality have the prefix `sync_`.
* *Asynchronous two-way:* The execution function returns a `Future` for awaiting the completion of a submitted function object and obtaining its result. The names of execution functions having asynchronous two-way directionality have the prefix `async_` or `then_`.

##### Requirements on execution functions of one-way directionality

In the Table below, `x` denotes a (possibly const) executor object of type `X`, `'e'` denotes an expression from the requirements on blocking semantics and `f` denotes a function object of type `F&&` callable as `DECAY_COPY(std::forward<F>(f))()` and where `decay_t<F>` satisfies the `MoveConstructible` requirements.

| Expression | Return Type | Operational semantics |
|------------|-------------|---------------------- |
| `x.'e'(...)` <br/> `'e'(x, ...)` | void | [*Note:* If `f()` exits via an exception, the behavior is specific to the executor. *--end note.*] |

##### Requirements on execution functions of synchronous two-way directionality

In the Table below, `x` denotes a (possibly const) executor object of type `X`, `'e'` denotes an expression from the requirements on blocking semantics and `f` denotes a function object of type `F&&` callable as `DECAY_COPY(std::forward<F>(f))()` and where `decay_t<F>` satisfies the `MoveConstructible` requirements.

| Expression | Return Type | Operational semantics |
|------------|-------------|---------------------- |
| `x.sync_'e'(...)` <br/> `sync_'e'(x, ...)` | `R` | Returns the result of `f()`. <br/><br/> Throws any exception thrown by `f()`. <br/> <br/> Must block forward progress of the caller until `DECAY_COPY( std::forward<F>(f))()` finishes execution. |

##### Requirements on execution functions of asynchronous two-way directionality

In the Table below, `x` denotes a (possibly const) executor object of type `X`, `'e'` denotes an expression from the requirements on blocking semantics, `f` denotes a function object of type `F&&` callable as `DECAY_COPY(std::forward<F>(f))()` and where `decay_t<F>` satisfies the `MoveConstructible` requirements and `pred` denotes a `Future` object whose result is `pr`.

| Expression | Return Type | Operational semantics |
|------------|-------------|---------------------- |
| `x.async_'e'(...)` <br/> `async_'e'(x, ...)` | A type that satisfies the `Future` requirements for the value type `R`. |  Stores the result of `f()`, or any exception thrown by `f()`, in the associated shared state of the resulting `Future`. |
| `x.then_'e'(..., pred, ...)` <br/> `then_'e'(x, ..., pred, ...)` | A type that satisfies the `Future` requirements for the value type `R`. | Stores the result of `f(pr)`, or any exception thrown by `f(pr)`, in the associated shared state of the resulting `Future`. |

#### Cardinality

The cardinality property of an execution function may be one of the following:

* *Single:* The execution function creates a single execution agent. The names of execution functions having single cardinality do not have an associated prefix.
* *Bulk:* The execution function creates multiple execution agents from a single invocation, with the number determined at runtime. The names of execution functions having bulk cardinality have the prefix `bulk_`.

##### Requirements on execution functions of single cardinality

In the Table below, `x` denotes a (possibly const) executor object of type `X`, `'e'` denotes an expression from the requirements on directionality, `'ret'` denotes the return type of the execution function from previous properties, `f` denotes a function object of type `F&&` callable as `DECAY_COPY(std::forward<F>(f))()` and where `decay_t<F>` satisfies the `MoveConstructible` requirements, and `a` denotes a (possibly const) value of type `A` satisfying the `ProtoAllocator` requirements.

| Expression | Return Type | Operational semantics |
|------------|-------------|---------------------- |
| `x.'e'(...)` <br/>`'e'(x, ...)` <br/> `x.'e'(..., a)` <br/>`'e'(x, ..., a)` | `'ret'` | Executor implementations should use the supplied allocator (if any) to allocate any memory required to store the function object. Prior to invoking the function object, the executor shall deallocate any memory allocated. [*Note:* Executors defined in this Technical Specification always use the supplied allocator unless otherwise specified. *--end note*] |

##### Requirements on execution functions of bulk cardinality

In the Table below,

  * `x` denotes a (possibly const) executor object of type `X`,
  * `'e'` denotes an expression from the requirements on directionality,
  * `'ret'` denotes the return type of the execution function from previous properties,
  * `f` denotes a function object of type `F&&` callable as `DECAY_COPY(std::forward<F>(f))(i, r, s)` and where `decay_t<F>` satisfies the `MoveConstructible` requirements where
    * `i` denotes an object whose type is `executor_index_t<X>`,
    * `r` denotes an object whose type is `R`,
    * `s` denotes an object whose type is `S`,
  * `n` denotes a shape object whose type is `executor_shape_t<X>`,
  * `rf` denotes a `CopyConstructible` function object with zero arguments whose result type is `R`,
  * `sf` denotes a `CopyConstructible` function object with zero arguments whose result type is `S`,
  * `pred` denotes a `Future` object whose result is `pr`.

| Expression | Return Type | Operational semantics |
|------------|-------------|---------------------- |
| `x.bulk_'e'(..., n, ...,[ rf,] sf)` <br/> `bulk_'e'(x, ..., n, ...,[ rf,] sf)` | `'ret'` | Creates a group of execution agents of shape `n` with forward progress guarantees of `executor_execution_mapping_category_t<X>` which invokes `DECAY_COPY( std::forward<F>(f))(i, r, s)` if `'ret'` is non void otherwise invokes `DECAY_COPY( std::forward<F>(f))(i, s)` , with the call to `DECAY_COPY` being evaluated in the thread that called `bulk_'e'`. <br/> <br/> Parameter `rf` is only included in the execution function if `'ret'` is non void. <br/> <br/> The value of type `R` returned is the result of `rf()` if `'ret'` is non void. <br/> <br/> Invokes `rf()` on an unspecified execution agent. <br/><br/> Invokes `sf()` on an unspecified execution agent. |

#### Execution function combinations

The table below describes the execution member functions and non-member functions that can be supported by an executor category via various combinations of the execution function requirements.

| Cardinality | Directionality | Blocking semantics | Member function | Free function |
| ------------ | -------------- | --------------------- | ------------------- | ---------------------- |
| Single | One-way | Potentially blocking | `x.execute(f)` <br/> `x.execute(f, a)` | `execute(x, f)` <br/> `execute(x, f, a)` |
| Single | One-way | Non-blocking | `x.post(f)` <br/> `x.post(f, a)` <br/> `x.defer(f)`  <br/> `x.defer(f, a)` | `post(x, f)` <br/> `post(x, f, a)` <br/> `defer(x, f)`  <br/> `defer(x, f, a)` |
| Single | Two-way synchronous | Potentially blocking | `x.sync_execute(f)` <br/> `x.sync_execute(f, a)` | `sync_execute(x, f)` <br/> `sync_execute(x, f, a)` |
| Single | Two-way synchronous | Non-blocking | NA | NA |
| Single | Two-way asynchronous | Potentially blocking | `x.async_execute(f)` <br/> `x.async_execute(f, a)`  <br/> `x.then_execute(f, pred)` <br/> `x.then_execute(f, pred, a)` | `async_execute(x, f)` <br/> `async_execute(x, f, a)`  <br/> `then_execute(x, f, pred)` <br/> `then_execute(x, f, pred, a)` |
| Single | Two-way asynchronous | Non-blocking | `x.async_post(f)` <br/> `x.async_post(f, a)` <br/> `x.async_defer(f)` <br/> `x.async_defer(f, a)` | `async_post(x, f)` <br/> `x.async_post(x, f, a)` <br/> `async_defer(x, f)` <br/> `x.async_defer(x, f, a)` |
| Bulk | One-way | Potentially blocking | `x.bulk_execute(f, n, sf)` | `bulk_execute(x, f, n, sf)` |
| Bulk | One-way | Non-blocking | `x.bulk_post(f, n, sf)` <br/> `x.bulk_defer(f, n, sf)` | `bulk_post(x, f, n, sf)` <br/> `bulk_defer(x, f, n, sf)` |
| Bulk | Two-way synchronous | Potentially blocking | `x.bulk_sync_execute(f, n, rf, sf)` | `bulk_sync_execute(x, f, n, rf, sf)` |
| Bulk | Two-way synchronous | Non-blocking | NA | NA |
| Bulk | Two-way asynchronous | Potentially blocking | `x.bulk_async_execute(f, n, rf, sf)` <br/> `x.bulk_then_execute(f, n, pred, rf, sf)` | `bulk_async_execute(x, f, n, rf, sf)` <br/> `bulk_then_execute(x, f, n, pred, rf, sf)` |
| Bulk | Two-way asynchronous | Non-blocking |  `x.bulk_async_post(f, n, rf, sf)` <br/> `x.bulk_async_defer(f, n, rf, sf)` | `bulk_async_post(x, f, n, rf, sf)` <br/> `bulk_async_defer(x, f, n, rf, sf)` |

### `BaseExecutor` requirements

A type `X` meets the `BaseExecutor` requirements if it satisfies the requirements of `CopyConstructible` (C++Std [copyconstructible]), `Destructible` (C++Std [destructible]), and `EqualityComparable` (C++Std [equalitycomparable]), as well as the additional requirements listed below.

No comparison operator, copy operation, move operation, swap operation, or member function `context` on these types shall exit via an exception.

The executor copy constructor, comparison operators, `context` member function, associated execution functions, and other member functions defined in refinements (TODO: what should this word be?) of the `BaseExecutor` requirements shall not introduce data races as a result of concurrent calls to those functions from different threads.

The destructor shall not block pending completion of the submitted function objects. [*Note:* The ability to wait for completion of submitted function objects may be provided by the associated execution context. *--end note*]

In the Table \ref{base_executor_requirements} below, `x1` and `x2` denote (possibly const) values of type `X`, `mx1` denotes an xvalue of type `X`, and `u` denotes an identifier.

Table: (Base executor requirements) \label{base_executor_requirements}

| Expression   | Type       | Assertion/note/pre-/post-condition |
|--------------|------------|------------------------------------|
| `X u(x1);` | | Shall not exit via an exception. <br/><br/>*Post:* `u == x1` and `u.context() == x1.context()`. |
| `X u(mx1);` | | Shall not exit via an exception. <br/><br/>*Post:* `u` equals the prior value of `mx1` and `u.context()` equals the prior value of `mx1.context()`. |
| `x1 == x2` | `bool` | Returns `true` only if `x1` and `x2` can be interchanged with identical effects in any of the expressions defined in these type requirements (TODO and the other executor requirements defined in this Technical Specification). [*Note:* Returning `false` does not necessarily imply that the effects are not identical. *--end note*] `operator==` shall be reflexive, symmetric, and transitive, and shall not exit via an exception. |
| `x1 != x2` | `bool` | Same as `!(x1 == x2)`. |
| `x1.context()` | `E&` or `const E&` where `E` is a type that satisfies the `ExecutionContext` requirements. | Shall not exit via an exception. The comparison operators and member functions defined in these requirements (TODO and the other executor requirements defined in this Technical Specification) shall not alter the reference returned by this function. |

### `OneWayExecutor` requirements

The `OneWayExecutor` requirements specify requirements for executors which create execution agents without a channel for awaiting the completion of a submitted function object and obtaining its result. [*Note:* That is, the executor provides fire-and-forget semantics. *--end note*]

A type `X` satisfies the `OneWayExecutor` requirements if it satisfies the `BaseExecutor` requirements, and `can_execute_v<X>` is true.

### `NonBlockingOneWayExecutor` requirements

The `NonBlockingOneWayExecutor` requirements refine the `OneWayExecutor` requirements by adding one-way operations that are guaranteed not to block the caller pending completion of submitted function objects.

A type `X` satisfies the `NonBlockingOneWayExecutor` requirements if it satisfies the `OneWayExecutor` requirements, `can_post_v<X>` is true, and `can_defer_v<X>` is true.

### `TwoWayExecutor` requirements

The `TwoWayExecutor` requirements specify requirements for executors which
creating execution agents with a channel for awaiting the completion of a
submitted function object and obtaining its result.

A type `X` satisfies the `TwoWayExecutor` requirements if it satisfies the `BaseExecutor` requirements, `can_sync_execute_v<X>` is true, and `can_async_execute_v<X>` is true.

### `BulkTwoWayExecutor` requirements

The `BulkTwoWayExecutor` requirements specify requirements for executors which
create groups of execution agents in bulk from a single execution function with
a channel for awaiting the completion of a submitted function object invoked by
those execution agents and obtaining its result.

A type `X` satisfies the `BulkTwoWayExecutor` requirements if it satisfies the `BaseExecutor` requirements, `can_bulk_sync_execute_v<X>` is true, `can_bulk_async_execute_v<X>` is true, and `can_bulk_then_execute_v<X>` is true.

### `ExecutorWorkTracker` requirements

The `ExecutorWorkTracker` requirements defines operations for tracking future work against an executor. These operations are used to advise an executor that function objects may be submitted to it at some point in the future.

A type `X` satisfies the `ExecutorWorkTracker` requirements if it satisfies the `BaseExecutor` requirements, as well as the additional requirements listed below.

No constructor, comparison operator, copy operation, move operation, swap operation, or member functions `on_work_started` and `on_work_finished` on these types shall exit via an exception.

The executor copy constructor, comparison operators, and other member functions defined in these requirements shall not introduce data races as a result of concurrent calls to those functions from different threads.

In the Table \ref{executor_work_tracker_requirements} below, `x` denotes an object of type `X`,

Table: (Executor Work Tracker requirements) \label{executor_work_tracker_requirements}

| Expression         | Return Type | Assertion/note/pre-/post-condition |
|--------------------|-------------|------------------------------------|
| `x.on_work_started()` | `bool` | Shall not exit via an exception. <br/>Must be paired with a corresponding subsequent call to `on_work_finished`. <br/>Returns `false` if the executor will not execute any further functions submitted to it; otherwise returns `true`. A return value of `true` does not guarantee that the executor will execute any further functions submitted to it.|
| `x.on_work_finished()` | | Shall not exit via an exception. <br/>Precondition: A corresponding preceding call to `on_work_started` that returned `true`. |

### Member detection type traits

    template<class T> struct has_execute_member;
    template<class T> struct has_post_member;
    template<class T> struct has_defer_member;
    template<class T> struct has_sync_execute_member;
    template<class T> struct has_async_execute_member;
    template<class T> struct has_async_post_member;
    template<class T> struct has_async_defer_member;
    template<class T> struct has_then_execute_member;
    template<class T> struct has_bulk_execute_member;
    template<class T> struct has_bulk_post_member;
    template<class T> struct has_bulk_defer_member;
    template<class T> struct has_bulk_sync_execute_member;
    template<class T> struct has_bulk_async_execute_member;
    template<class T> struct has_bulk_async_post_member;
    template<class T> struct has_bulk_async_defer_member;
    template<class T> struct has_bulk_then_execute_member;

This sub-clause contains templates that may be used to query the properties of a type at compile time. Each of these templates is a UnaryTypeTrait (C++Std [meta.rqmts]) with a BaseCharacteristic of `true_type` if the corresponding condition is true, otherwise `false_type`.

| Template                   | Condition           | Preconditions  |
|----------------------------|---------------------|----------------|
| `template<class T>` <br/>`struct has_execute_member` | `T` has a member function named `execute` that satisfies the syntactic requirements of a one-way, potentially blocking execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_post_member` | `T` has a member function named `post` that satisfies the syntactic requirements of a one-way, non-blocking execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_defer_member` | `T` has a member function named `defer` that satisfies the syntactic requirements of a one-way, non-blocking execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_sync_execute_member` | `T` has a member function named `sync_execute` that satisfies the syntactic requirements of a synchronous two-way execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_async_execute_member` | `T` has a member function named `async_execute` that satisfies the syntactic requirements of an asynchronous two-way, potentially blocking execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_async_post_member` | `T` has a member function named `async_post` that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_async_defer_member` | `T` has a member function named `async_defer` that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_then_execute_member` | `T` has a member function named `then_execute` that satisfies the syntactic requirements of an asynchronous two-way, potentially blocking execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_execute_member` | `T` has a member function named `bulk_execute` that satisfies the syntactic requirements of a one-way, potentially blocking execution function of bulk cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_post_member` | `T` has a member function named `bulk_post` that satisfies the syntactic requirements of a one-way, non-blocking execution function of bulk cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_defer_member` | `T` has a member function named `bulk_defer` that satisfies the syntactic requirements of a one-way, non-blocking execution function of bulk cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_sync_execute_member` | `T` has a member function named `bulk_sync_execute` that satisfies the syntactic requirements of a synchronous two-way execution function of bulk cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_async_execute_member` | `T` has a member function named `bulk_async_execute` that satisfies the syntactic requirements of an asynchronous two-way, potentially blocking execution function of bulk cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_async_post_member` | `T` has a member function named `bulk_async_post` that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of bulk cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_async_defer_member` | `T` has a member function named `bulk_async_defer` that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of bulk cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_then_execute_member` | `T` has a member function named `bulk_then_execute` that satisfies the syntactic requirements of an a asynchronous two-way, potentially blocking execution function of bulk cardinality. | `T` is a complete type. |

### Free function detection type traits

    template<class T> struct has_execute_free_function;
    template<class T> struct has_post_free_function;
    template<class T> struct has_defer_free_function;
    template<class T> struct has_sync_execute_free_function;
    template<class T> struct has_async_execute_free_function;
    template<class T> struct has_async_post_free_function;
    template<class T> struct has_async_defer_free_function;
    template<class T> struct has_then_execute_free_function;
    template<class T> struct has_bulk_execute_free_function;
    template<class T> struct has_bulk_post_free_function;
    template<class T> struct has_bulk_defer_free_function;
    template<class T> struct has_bulk_sync_execute_free_function;
    template<class T> struct has_bulk_async_execute_free_function;
    template<class T> struct has_bulk_async_post_free_function;
    template<class T> struct has_bulk_async_defer_free_function;
    template<class T> struct has_bulk_then_execute_free_function;

This sub-clause contains templates that may be used to query the properties of a type at compile time. Each of these templates is a UnaryTypeTrait (C++Std [meta.rqmts]) with a BaseCharacteristic of `true_type` if the corresponding condition is true, otherwise `false_type`.

| Template                   | Condition           | Preconditions  |
|----------------------------|---------------------|----------------|
| `template<class T>` <br/>`struct has_execute_free_function` | There exists a free function named `execute` taking an executor of type `T` that satisfies the syntactic requirements of a one-way, potentially blocking execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_post_free_function` | There exists a free function named `post` taking an executor of type `T` that satisfies the syntactic requirements of a one-way, non-blocking execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_defer_free_function` | There exists a free function named `defer` taking an executor of type `T` that satisfies the syntactic requirements of a one-way, non-blocking execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_sync_execute_free_function` | There exists a free function named `sync_execute` taking an executor of type `T` that satisfies the syntactic requirements of a synchronous two-way execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_async_execute_free_function` | There exists a free function named `async_execute` taking an executor of type `T` that satisfies the syntactic requirements of an asynchronous two-way, potentially blocking execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_async_post_free_function` | There exists a free function named `async_post` taking an executor of type `T` that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_async_defer_free_function` | There exists a free function named `async_defer` taking an executor of type `T` that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_then_execute_free_function` | There exists a free function named `then_execute` taking an executor of type `T` that satisfies the syntactic requirements of an asynchronous two-way, potentially blocking execution function of single cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_execute_free_function` | There exists a free function named `bulk_execute` taking an executor of type `T` that satisfies the syntactic requirements of a one-way, potentially blocking execution function of bulk cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_post_free_function` | There exists a free function named `bulk_post` taking an executor of type `T` that satisfies the syntactic requirements of a one-way, non-blocking execution function of bulk cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_defer_free_function` | There exists a free function named `bulk_defer` taking an executor of type `T` that satisfies the syntactic requirements of a one-way, non-blocking execution function of bulk cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_sync_execute_free_function` | There exists a free function named `bulk_sync_execute` taking an executor of type `T` that satisfies the syntactic requirements of a synchronous two-way execution function of bulk cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_async_execute_free_function` | There exists a free function named `bulk_async_execute` taking an executor of type `T` that satisfies the syntactic requirements of an asynchronous two-way, potentially blocking execution function of bulk cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_async_post_free_function` | There exists a free function named `bulk_async_post` taking an executor of type `T` that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of bulk cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_async_defer_free_function` | There exists a free function named `bulk_async_defer` taking an executor of type `T` that satisfies the syntactic requirements of an asynchronous two-way, non-blocking execution function of bulk cardinality. | `T` is a complete type. |
| `template<class T>` <br/>`struct has_bulk_then_execute_free_function` | There exists a free function named `bulk_then_execute` taking an executor of type `T` that satisfies the syntactic requirements of an an asynchronous two-way, potentially blocking execution function of bulk cardinality. | `T` is a complete type. |

## Executor customization points

*Executor customization points* are execution functions which adapt an executor's free and member execution functions to create execution agents. Executor customization points enable uniform use of executors in generic contexts.

When an executor customization point named *NAME* invokes a free execution function of the same name, overload resolution is performed in a context that includes the declaration `void` *NAME*`(auto&... args) = delete;`, where `sizeof...(args)` is the arity of the free execution function. This context also does not include a declaration of the executor customization point.

[*Note:* This provision allows executor customization points to call the executor's free, non-member execution function of the same name without recursion. *--end note*]

Whenever `std::experimental::concurrency_v2::execution::`*NAME*`(`*ARGS*`)` is a valid expression, that expression satisfies the syntactic requirements for the free execution function named *NAME* with arity `sizeof...(`*ARGS*`)` with that free execution function's semantics.

### `execute`

    namespace {
      constexpr unspecified execute = unspecified;
    }

The name `execute` denotes a customization point. The effect of the expression `std::experimental::concurrency_v2::execution::execute(E, F, A...)` for some expressions `E` and `F`, and where `A...` represents 0 or 1 expressions, is equivalent to:

* `(E).execute(F, A...)` if `has_execute_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `execute(E, F, A...)` if `has_execute_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::execute(E, F, A...)` is ill-formed.

### `post`

    namespace {
      constexpr unspecified post = unspecified;
    }

The name `post` denotes a customization point. The effect of the expression `std::experimental::concurrency_v2::execution::post(E, F, A...)` for some expressions `E` and `F`, and where `A...` represents 0 or 1 expressions, is equivalent to:

* `(E).post(F, A...)` if `has_post_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `post(E, F, A...)` if `has_post_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::execute(E, F, A...)` if `can_execute_v<decay_t<decltype(E)>> && is_same_v<execution_execute_blocking_category_t<decay_t<decltype(E)>>, non_blocking_execution_tag>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::post(E, F, A...)` is ill-formed.

### `defer`

    namespace {
      constexpr unspecified defer = unspecified;
    }

The name `defer` denotes a customization point. The effect of the expression `std::experimental::concurrency_v2::execution::defer(E, F, A...)` for some expressions `E` and `F`, and where `A...` represents 0 or 1 expressions, is equivalent to:

* `(E).defer(F, A...)` if `has_defer_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `defer(E, F, A...)` if `has_defer_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::execute(E, F, A...)` if `can_execute_v<decay_t<decltype(E)>> && is_same_v<execution_execute_blocking_category_t<decay_t<decltype(E)>>, non_blocking_execution_tag>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::defer(E, F, A...)` is ill-formed.

### `sync_execute`

    namespace {
      constexpr unspecified sync_execute = unspecified;
    }

The name `sync_execute` denotes a customization point. The effect of the expression `std::experimental::concurrency_v2::execution::sync_execute(E, F, A...)` for some expressions `E` and `F`, and where `A...` represents 0 or 1 expressions, is equivalent to:

* `(E).sync_execute(F, A...)` if `has_sync_execute_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `sync_execute(E, F, A...)` if `has_sync_execute_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::async_execute(E, F, A...).get()` if `can_async_execute_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::sync_execute(E, F, A...)` is ill-formed.

### `async_execute`

    namespace {
      constexpr unspecified async_execute = unspecified;
    }

The name `async_execute` denotes a customization point. The effect of the expression `std::experimental::concurrency_v2::execution::async_execute(E, F, A...)` for some expressions `E` and `F`, and where `A...` represents 0 or 1 expressions, is equivalent to:

* `(E).async_execute(F, A...)` if `has_async_execute_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `async_execute(E, F, A...)` if `has_async_execute_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, if `can_execute_v<decay_t<decltype(E)>>` is true, creates an asynchronous provider with an associated shared state (C++Std [futures.state]). Calls `std::experimental::concurrency_v2::execution::execute(E, g, A...)` where `g` is a function object of unspecified type that performs `DECAY_COPY(F)()`, with the call to `DECAY_COPY` being performed in the thread that called `async_execute`. On successful completion of `DECAY_COPY(F)()`, the return value of `DECAY_COPY(F)()` is atomically stored in the shared state and the shared state is made ready. If `DECAY_COPY(F)()` exits via an exception, the exception is atomically stored in the shared state and the shared state is made ready. The result of the expression `std::experimental::concurrency_v2::execution::async_execute(E, F, A...)` is an object of type `std::future<result_of_t<decay_t<decltype(F)>>()>` that refers to the shared state.

* Otherwise, `std::experimental::concurrency_v2::execution::async_execute(E, F, A...)` is ill-formed.

### `async_post`

    namespace {
      constexpr unspecified async_post = unspecified;
    }

The name `async_post` denotes a customization point. The effect of the expression `std::experimental::concurrency_v2::execution::async_post(E, F, A...)` for some expressions `E` and `F`, and where `A...` represents 0 or 1 expressions, is equivalent to:

* `(E).async_post(F, A...)` if `has_async_post_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `async_post(E, F, A...)` if `has_async_post_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::async_execute(E, F, A...)` if `can_async_execute_v<decay_t<decltype(E)>> && is_same_v<execution_execute_blocking_category_t<decay_t<decltype(E)>>, non_blocking_execution_tag>` is true.

* Otherwise, if `can_post_v<decay_t<decltype(E)>>` is true, creates an asynchronous provider with an associated shared state (C++Std [futures.state]). Calls `std::experimental::concurrency_v2::execution::execute(E, g, A...)` where `g` is a function object of unspecified type that performs `DECAY_COPY(F)()`, with the call to `DECAY_COPY` being performed in the thread that called `async_post`. On successful completion of `DECAY_COPY(F)()`, the return value of `DECAY_COPY(F)()` is atomically stored in the shared state and the shared state is made ready. If `DECAY_COPY(F)()` exits via an exception, the exception is atomically stored in the shared state and the shared state is made ready. The result of the expression `std::experimental::concurrency_v2::execution::async_post(E, F, A...)` is an object of type `std::future<result_of_t<decay_t<decltype(F)>>()>` that refers to the shared state.

* Otherwise, `std::experimental::concurrency_v2::execution::async_post(E, F, A...)` is ill-formed.

### `async_defer`

    namespace {
      constexpr unspecified async_defer = unspecified;
    }

The name `async_defer` denotes a customization point. The effect of the expression `std::experimental::concurrency_v2::execution::async_defer(E, F, A...)` for some expressions `E` and `F`, and where `A...` represents 0 or 1 expressions, is equivalent to:

* `(E).async_defer(F, A...)` if `has_async_defer_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `async_defer(E, F, A...)` if `has_async_defer_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::async_execute(E, F, A...)` if `can_async_execute_v<decay_t<decltype(E)>> && is_same_v<execution_execute_blocking_category_t<decay_t<decltype(E)>>, non_blocking_execution_tag>` is true.

* Otherwise, if `can_defer_v<decay_t<decltype(E)>>` is true, creates an asynchronous provider with an associated shared state (C++Std [futures.state]). Calls `std::experimental::concurrency_v2::execution::execute(E, g, A...)` where `g` is a function object of unspecified type that performs `DECAY_COPY(F)()`, with the call to `DECAY_COPY` being performed in the thread that called `async_defer`. On successful completion of `DECAY_COPY(F)()`, the return value of `DECAY_COPY(F)()` is atomically stored in the shared state and the shared state is made ready. If `DECAY_COPY(F)()` exits via an exception, the exception is atomically stored in the shared state and the shared state is made ready. The result of the expression `std::experimental::concurrency_v2::execution::async_defer(E, F, A...)` is an object of type `std::future<result_of_t<decay_t<decltype(F)>>()>` that refers to the shared state.

* Otherwise, `std::experimental::concurrency_v2::execution::async_defer(E, F, A...)` is ill-formed.

### `then_execute`

    namespace {
      constexpr unspecified then_execute = unspecified;
    }

The name `then_execute` denotes a customization point. The effect of the expression `std::experimental::concurrency_v2::execution::then_execute(E, F, P, A...)` for some expressions `E`, `F`, and `P`, and where `A...` represents 0 or 1 expressions, is equivalent to:

* `(E).then_execute(F, P, A...)` if `has_then_execute_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `then_execute(E, F, P, A...)` if `has_then_execute_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, equivalent to

        auto __g = [__f = forward<decltype(F)>(F)](decltype(P)& __predecessor_future)
        {
          auto __predecessor_result = __predecessor_future.get();
          return __f(__predecessor_result);
        }
        
        return (P).then(E, std::move(__g));

    when `P` is a non-`void` future. Otherwise,

        auto __g = [__f = forward<decltype(F)>(F)](decltype(P)&)
        {
          return __f();
        }

        return (P).then(E, std::move(__g));

* Otherwise, `std::experimental::concurrency_v2::execution::then_execute(E, F, P, A...)` is ill-formed

### `bulk_execute`

    namespace {
      constexpr unspecified bulk_execute = unspecified;
    }

The name `bulk_execute` denotes a customization point. The effect of the expression `std::experimental::concurrency_v2::execution::bulk_execute(E, F, S, SF)` for some expressions `E`, `F`, `S`, and `SF` is equivalent to:

* `(E).bulk_execute(F, S, SF)` if `has_bulk_execute_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `bulk_execute(E, F, S, SF)` if `has_bulk_execute_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::bulk_execute(E, F, S, SF)` is ill-formed.

### `bulk_post`

    namespace {
      constexpr unspecified bulk_post = unspecified;
    }

The name `bulk_post` denotes a customization point. The effect of the expression `std::experimental::concurrency_v2::execution::bulk_post(E, F, S, SF)` for some expressions `E`, `F`, `S`, and `SF` is equivalent to:

* `(E).bulk_post(F, S, SF)` if `has_bulk_post_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `bulk_post(E, F, S, SF)` if `has_bulk_post_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::bulk_execute(E, F, S, SF)` if `can_bulk_execute_v<decay_t<decltype(E)>> && is_same_v<execution_execute_blocking_category_t<decay_t<decltype(E)>>, non_blocking_execution_tag>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::bulk_post(E, F, S, SF)` is ill-formed.

### `bulk_defer`

    namespace {
      constexpr unspecified bulk_defer = unspecified;
    }

The name `bulk_defer` denotes a customization point. The effect of the expression `std::experimental::concurrency_v2::execution::bulk_defer(E, F, S, SF)` for some expressions `E`, `F`, `S`, and `SF` is equivalent to:

* `(E).bulk_defer(F, S, SF)` if `has_bulk_defer_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `bulk_defer(E, F, S, SF)` if `has_bulk_defer_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::bulk_execute(E, F, S, SF)` if `can_bulk_execute_v<decay_t<decltype(E)>> && is_same_v<execution_execute_blocking_category_t<decay_t<decltype(E)>>, non_blocking_execution_tag>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::bulk_defer(E, F, S, SF)` is ill-formed.

### `bulk_sync_execute`

    namespace {
      constexpr unspecified bulk_sync_execute = unspecified;
    }

The name `bulk_sync_execute` denotes a customization point. The effect of the expression `std::experimental::concurrency_v2::execution::bulk_sync_execute(E, F, S, RF, SF)` for some expressions `E`, `F`, `S`, `RF`, and `SF` is equivalent to:

* `(E).bulk_sync_execute(F, S, RF, SF)` if `has_bulk_sync_execute_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `bulk_sync_execute(E, F, S, RF, SF)` if `has_bulk_sync_execute_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::bulk_async_execute(E, F, S, RF, SF).get()` if `can_bulk_async_execute_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::bulk_sync_execute(E, F, S, RF, SF)` is ill-formed.

### `bulk_async_execute`

    namespace {
      constexpr unspecified bulk_async_execute = unspecified;
    }

The name `bulk_async_execute` denotes a customization point. The effect of the expression `std::experimental::concurrency_v2::execution::bulk_async_execute(E, F, S, RF, SF)` for some expressions `E`, `F`, `S`, `RF`, and `SF` is equivalent to:

* `(E).bulk_async_execute(F, S, RF, SF)` if `has_bulk_async_execute_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `bulk_async_execute(E, F, S, RF, SF)` if `has_bulk_async_execute_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::bulk_then_execute(E, F, S, std::experimental::make_ready_future(), RF, SF)` if `can_bulk_then_execute_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::bulk_async_execute(E, F, S, RF, SF)` is ill-formed.

### `bulk_async_post`

    namespace {
      constexpr unspecified bulk_async_post = unspecified;
    }

The name `bulk_async_post` denotes a customization point. The effect of the expression `std::experimental::concurrency_v2::execution::bulk_async_post(E, F, S, RF, SF)` for some expressions `E`, `F`, `S`, `RF`, and `SF` is equivalent to:

* `(E).bulk_async_post(F, S, RF, SF)` if `has_bulk_async_post_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `bulk_async_post(E, F, S, RF, SF)` if `has_bulk_async_post_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::bulk_async_execute(E, F, S, RF, SF)` if `can_bulk_async_execute_v<decay_t<decltype(E)>> && is_same_v<execution_execute_blocking_category_t<decay_t<decltype(E)>>, non_blocking_execution_tag>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::bulk_async_post(E, F)` is ill-formed.

### `bulk_async_defer`

    namespace {
      constexpr unspecified bulk_async_defer = unspecified;
    }

The name `bulk_async_defer` denotes a customization point. The effect of the expression `std::experimental::concurrency_v2::execution::bulk_async_defer(E, F, S, RF, SF)` for some expressions `E`, `F`, `S`, `RF`, and `SF` is equivalent to:

* `(E).bulk_async_defer(F, S, RF, SF)` if `has_bulk_async_defer_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `bulk_async_defer(E, F, S, RF, SF)` if `has_bulk_async_defer_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::bulk_async_execute(E, F, S, RF, SF)` if `can_bulk_async_execute_v<decay_t<decltype(E)>> && is_same_v<execution_execute_blocking_category_t<decay_t<decltype(E)>>, non_blocking_execution_tag>` is true.

* Otherwise, `std::experimental::concurrency_v2::execution::bulk_async_defer(E, F)` is ill-formed.

### `bulk_then_execute`

    namespace {
      constexpr unspecified bulk_then_execute = unspecified;
    }

The name `bulk_then_execute` denotes a customization point. The effect of the expression `std::expression::concurrency_v2::execution::bulk_then_execute(E, F, S, P, RF, SF)` for some expressions `E`, `F`, `S`, `P`, `RF`, and `SF` is equivalent to:

* `(E).bulk_then_execute(F, S, P, RF, SF)` if `has_bulk_then_execute_member_v<decay_t<decltype(E)>>` is true.

* Otherwise, `bulk_then_execute(E, F, S, P, RF, SF)` if `has_bulk_then_execute_free_function_v<decay_t<decltype(E)>>` is true.

* Otherwise, let `DE` be `decay_t<decltype(E)>`. If `can_then_execute_v<DE> && (has_bulk_sync_execute_member_v<DE> || has_bulk_sync_execute_free_function_v<DE> || has_bulk_async_execute_member_v<DE> || has_bulk_async_execute_free_function_v<DE>)` is true, equivalent to the following:

        auto __f = F;

        auto __g = [=](auto& __predecessor)
        {
          return std::experimental::concurrency_v2::bulk_sync_execute(E, S, RF, SF,
            [=,&__predecessor](auto& __result, auto& __shared)
          {
            __f(__i, __predecessor, __result, __shared);
          });
        };

        return std::experimental::concurrency_v2::execution::then_execute(E, __g, P);

    if `P` is a non-`void` future. Otherwise,

        auto __f = F;

        auto __g = [=]
        {
          return std::experimental::concurrency_v2::bulk_sync_execute(E, S, RF, SF,
            [=](auto& __result, auto& __shared)
          {
            __f(__i, __result, __shared);
          });
        };

        return std::experimental::concurrency_v2::execution::then_execute(E, __g, P);

    [*Note:* The explicit use of execution function detectors for `bulk_sync_execute` and `bulk_async_execute` above is intentional to avoid cycles in this code. *--end note*]

* Otherwise, `std::experimental::concurrency_v2::execution::bulk_then_execute(E, F, S, P, RF, SF)` is ill-formed.

### Customization point type traits

    template<class T> struct can_execute;
    template<class T> struct can_post;
    template<class T> struct can_defer;
    template<class T> struct can_sync_execute;
    template<class T> struct can_async_execute;
    template<class T> struct can_async_post;
    template<class T> struct can_async_defer;
    template<class T> struct can_then_execute;
    template<class T> struct can_bulk_execute;
    template<class T> struct can_bulk_post;
    template<class T> struct can_bulk_defer;
    template<class T> struct can_bulk_sync_execute;
    template<class T> struct can_bulk_async_execute;
    template<class T> struct can_bulk_async_post;
    template<class T> struct can_bulk_async_defer;
    template<class T> struct can_bulk_then_execute;

This sub-clause contains templates that may be used to query the properties of a type at compile time. Each of these templates is a UnaryTypeTrait (C++Std [meta.rqmts]) with a BaseCharacteristic of `true_type` if the corresponding condition is true, otherwise `false_type`.

In the Table below,

* `t` denotes a (possibly const) executor object of type `T`,
* `f` denotes a function object of type `F&&` callable as `DECAY_COPY(std::forward<F>(f))()`, where `decay_t<F>` satisfies the `MoveConstructible` requirements.
* `bof` denotes a function object of type `F&&` callable as `DECAY_COPY(std::forward<F>(bof))(i, s)`,
    * where `i` denotes an object whose type is `executor_index_t<X>`,
    * where `s` denotes an object whose type is `S` and
    * where `decay_t<F>` satisfies the `CopyConstructible` requirements,
* `btf` denotes a function object of type `F&&` callable as `DECAY_COPY(std::forward<F>(btf))(i, r, s)`,
    * where `i` denotes an object whose type is `executor_index_t<X>`,
    * where `r` denotes an object whose type is `R`,
    * where `s` denotes an object whose type is `S` and
    * where `decay_t<F>` satisfies the `CopyConstructible` requirements,
* `bcf` denotes a function object of type `F&&` callable as `DECAY_COPY(std::forward<F>(bcf))(i, p, r, s)`,
    * where `i` denotes an object whose type is `executor_index_t<X>`,
    * where `p` denotes an object whose type is `P`,
    * where `r` denotes an object whose type is `R`,
    * where `s` denotes an object whose type is `S` and
    * where `decay_t<F>` satisfies the `CopyConstructible` requirements,
* `rf` denotes a `CopyConstructible` function object with zero arguments whose result type is `R`,
* `sf` denotes a `CopyConstructible` function object with zero arguments whose result type is `S`,
* `pred` denotes a `Future` object whose result type is `P` and
* `a` denotes a (possibly const) value of type `A` satisfying the `ProtoAllocator` requirements.

| Template                   | Conditions           | Preconditions  |
|----------------------------|---------------------|----------------|
| `template<class T>` <br/> `struct can_execute` | The expressions `std::experimental::concurrency_v2::execution::execute(t, f)` and `std::experimental::concurrency_v2::execution::execute(t, f, a)` are well-formed. | `T` is a complete type. |
| `template<class T>` <br/>`struct can_post` | The expressions `std::experimental::concurrency_v2::execution::post(t, f)` and `std::experimental::concurrency_v2::execution::post(t, f, a)` are well-formed. | `T` is a complete type. |
| `template<class T>` <br/>`struct can_defer` | The expressions `std::experimental::concurrency_v2::execution::defer(t, f)` and `std::experimental::concurrency_v2::execution::defer(t, f, a)` are well-formed. | `T` is a complete type. |
| `template<class T>` <br/>`struct can_sync_execute` | The expressions `std::experimental::concurrency_v2::execution::sync_execute(t, f)` and `std::experimental::concurrency_v2::execution::sync_execute(t, f, a)` are well-formed. | `T` is a complete type. |
| `template<class T>` <br/>`struct can_async_execute` | The expressions `std::experimental::concurrency_v2::execution::async_execute(t, f)` and `std::experimental::concurrency_v2::execution::async_execute(t, f, a)` are well-formed. | `T` is a complete type. |
| `template<class T>` <br/>`struct can_async_post` | The expressions `std::experimental::concurrency_v2::execution::async_post(t, f)` and `std::experimental::concurrency_v2::execution::async_post(t, f, a)` are well-formed. | `T` is a complete type. |
| `template<class T>` <br/>`struct can_async_defer` | The expressions `std::experimental::concurrency_v2::execution::async_defer(t, f)` and `std::experimental::concurrency_v2::execution::async_defer(t, f, a)` is well-formed. | `T` is a complete type. |
| `template<class T>` <br/>`struct can_then_execute` | The expressions `std::experimental::concurrency_v2::execution::then_execute(t, f, pred)` and `std::experimental::concurrency_v2::execution::then_execute(t, f, pred)` are well-formed. | `T` is a complete type. |
| `template<class T>` <br/>`struct can_bulk_execute` | The expression `std::experimental::concurrency_v2::execution::bulk_execute(t, bof, s, sf)` is well-formed. | `T` is a complete type. |
| `template<class T>` <br/>`struct can_bulk_post` | The expression `std::experimental::concurrency_v2::execution::bulk_post(t, bof, s, sf)` is well-formed. | `T` is a complete type. |
| `template<class T>` <br/>`struct can_bulk_defer` | The expression `std::experimental::concurrency_v2::execution::bulk_defer(t, bof, s, sf)` is well-formed. | `T` is a complete type. |
| `template<class T>` <br/>`struct can_bulk_sync_execute` | The expression `std::experimental::concurrency_v2::execution::bulk_sync_execute(t, btf, s, rf, sf)` is well-formed. | `T` is a complete type. |
| `template<class T>` <br/>`struct can_bulk_async_execute` | The expression `std::experimental::concurrency_v2::execution::bulk_async_execute(t, btf, s, rf, sf)` is well-formed. | `T` is a complete type. |
| `template<class T>` <br/>`struct can_bulk_async_post` | The expression `std::experimental::concurrency_v2::execution::bulk_async_post(t, btf, s, rf, sf)` is well-formed. | `T` is a complete type. |
| `template<class T>` <br/>`struct can_bulk_async_defer` | The expression `std::experimental::concurrency_v2::execution::bulk_async_defer(t, btf, s, rf, sf)` is well-formed. | `T` is a complete type. |
| `template<class T>` <br/>`struct can_bulk_then_execute` | The expression `std::experimental::concurrency_v2::execution::bulk_then_execute(t, bcf, s, pred, rf, sf)` is well-formed. | `T` is a complete type. |

## Executor type traits

### Determining that a type satisfies executor category requirements

    template<class T> struct is_one_way_executor;
    template<class T> struct is_non_blocking_one_way_executor;
    template<class T> struct is_two_way_executor;
    template<class T> struct is_bulk_two_way_executor;

This sub-clause contains templates that may be used to query the properties of a type at compile time. Each of these templates is a UnaryTypeTrait (C++Std [meta.rqmts]) with a BaseCharacteristic of `true_type` if the corresponding condition is true, otherwise `false_type`.

| Template                   | Condition           | Preconditions  |
|----------------------------|---------------------|----------------|
| `template<class T>` <br/>`struct is_one_way_executor` | `T` meets the syntactic requirements for `OneWayExecutor`. | `T` is a complete type. |
| `template<class T>` <br/>`struct is_non_blocking_one_way_executor` | `T` meets the syntactic requirements for `NonBlockingOneWayExecutor`. | `T` is a complete type. |
| `template<class T>` <br/>`struct is_two_way_executor` | `T` meets the syntactic requirements for `TwoWayExecutor`. | `T` is a complete type. |
| `template<class T>` <br/>`struct is_bulk_two_way_executor` | `T` meets the syntactic requirements for `BulkTwoWayExecutor`. | `T` is a complete type. |

### Associated execution context type

    template<class Executor>
    struct executor_context
    {
      using type = std::decay_t<decltype(declval<const Executor&>().context())>; // TODO check this
    };

### Associated future type

    template<class Executor, class T>
    struct executor_future
    {
      using type = see below;
    };
    
The type of `executor_future<Executor, T>::type` is determined as follows:

* if `is_two_way_executor<Executor>` is true, `decltype(declval<const Executor&>().async_execute( declval<T(*)()>())`;

* otherwise, if `is_one_way_executor<Executor>` is true, `std::future<T>`;

* otherwise, the program is ill formed.

[*Note:* The effect of this specification is that all execute functions of an executor that satisfies the `TwoWayExecutor`, `NonBlockingTwoWayExecutor`, or `BulkTwoWayExecutor` requirements must utilize the same future type, and that this future type is determined by `async_execute`. Programs may specialize this trait for user-defined `Executor` types. *--end note*]

### Classifying the mapping of execution agents

    struct other_execution_mapping_tag {};
    struct thread_execution_mapping_tag {};
    struct unique_thread_execution_mapping_tag {};

    template<class Executor>
    struct executor_execution_mapping_category
    {
      private:
        // exposition only
        template<class T>
        using helper = typename T::execution_mapping_category;

      public:
        using type = std::experimental::detected_or_t<
          thread_execution_mapping_tag, helper, Executor
        >;
    };

Components which create execution agents may use *execution mapping categories*
to communicate the mapping of execution agents onto threads of execution.
Execution mapping categories encode the characterisitics of that mapping, if it
exists.

`other_execution_mapping_tag` indicates that execution agents created by a
component may be mapped onto execution resources other than threads of
execution.

`thread_execution_mapping_tag` indicates that execution agents created by a
component are mapped onto threads of execution.

`unique_thread_execution_mapping_tag` indicates that each execution agent
created by a component is mapped onto a new thread of execution.

[*Note:* A mapping of an execution agent onto a thread of execution implies the
agent executes as-if on a `std::thread`. Therefore, the facilities provided by
`std::thread`, such as thread-local storage, are available.
`unique_thread_execution_mapping_tag` provides stronger guarantees, in
particular that thread-local storage will not be shared between execution
agents. *--end note*]

### Classifying the blocking behavior of potentially blocking operations

    struct blocking_execution_tag {};
    struct possibly_blocking_execution_tag {};
    struct non_blocking_execution_tag {};

    template<class Executor>
    struct executor_execute_blocking_category
    {
      private:
        // exposition only
        template<class T>
        using helper = typename T::blocking_category;

      public:
        using type = std::experimental::detected_or_t<
          possibly_blocking_execution_tag, helper, Executor
        >;
    };

Components which create possibly blocking execution may use *blocking categories*
to communicate the way in which this execution blocks the progress of its caller.

`blocking_execution_tag` indicates that a component blocks its caller's
progress pending the completion of the execution agents created by that component.

`possibly_blocking_execution_tag` indicates that a component may block its
caller's progress pending the completion of the execution agents created by that
component.

`non_blocking_execution_tag` indicates that a component does not block its
caller's progress pending the completion of the execution agents created by that
component.

Programs may use `executor_execute_blocking_category` to query the blocking behavior of
executor customization points whose semantics allow the possibility of
blocking.

[*Note:* These customization points which allow the possibility of blocking are `execute`, `async_execute`, `then_execute`, `bulk_execute`, `bulk_async_execute`, and `bulk_then_execute`. *--end note*]

## Bulk executor traits

### Classifying forward progress guarantees of groups of execution agents

    struct sequenced_execution_tag {};
    struct parallel_execution_tag {};
    struct unsequenced_execution_tag {};

    template<class Executor>
    struct executor_execution_category
    {
      private:
        // exposition only
        template<class T>
        using helper = typename T::execution_category;

      public:
        using type = std::experimental::detected_or_t<
          unsequenced_execution_tag, helper, Executor
        >;
    };

Components which create groups of execution agents may use *execution
categories* to communicate the forward progress and ordering guarantees of
these execution agents with respect to other agents within the same group.
  
TODO: *The meanings and relative "strength" of these categores are to be defined.
Most of the wording for `sequenced_execution_tag`, `parallel_execution_tag`,
and `unsequenced_execution_tag` can be migrated from S 25.2.3 p2, p3, and
p4, respectively.*

### Associated shape type

    template<class Executor>
    struct executor_shape
    {
      private:
        // exposition only
        template<class T>
        using helper = typename T::shape_type;
    
      public:
        using type = std::experimental::detected_or_t<
          size_t, helper, Executor
        >;

        // exposition only
        static_assert(std::is_integral_v<type>, "shape type must be an integral type");
    };

### Associated index type

    template<class Executor>
    struct executor_index
    {
      private:
        // exposition only
        template<class T>
        using helper = typename T::index_type;

      public:
        using type = std::experimental::detected_or_t<
          executor_shape_t<Executor>, helper, Executor
        >;

        // exposition only
        static_assert(std::is_integral_v<type>, "index type must be an integral type");
    };

## Executor work guard

```
template<class Executor>
class executor_work_guard
{
public:
  // types:

  typedef Executor executor_type;

  // construct / copy / destroy:

  explicit executor_work_guard(const executor_type& ex) noexcept;
  executor_work_guard(const executor_work_guard& other) noexcept;
  executor_work_guard(executor_work_guard&& other) noexcept;

  executor_work_guard& operator=(const executor_work_guard&) = delete;

  ~executor_work_guard();

  // executor work guard observers:

  executor_type get_executor() const noexcept;
  bool owns_work() const noexcept;

  // executor work guard modifiers:

  void reset() noexcept;

private:
  Executor ex_; // exposition only
  bool owns_; // exposition only
};
```

### Members

```
explicit executor_work_guard(const executor_type& ex) noexcept;
```

*Effects:* Initializes `ex_` with `ex`, and `owns_` with the result of
`ex_.on_work_started()`.

*Postconditions:* `ex_ == ex`.

```
executor_work_guard(const executor_work_guard& other) noexcept;
```

*Effects:* Initializes `ex_` with `other.ex_`. If `other.owns_ == true`,
initializes `owns_` with the result of `ex_.on_work_started()`; otherwise, sets
`owns_` to false.

*Postconditions:* `ex_ == other.ex_`.

```
executor_work_guard(executor_work_guard&& other) noexcept;
```

*Effects:* Initializes `ex_` with `std::move(other.ex_)` and `owns_` with
`other.owns_`, and sets `other.owns_` to `false`.

```
~executor_work_guard();
```

*Effects:* If `owns_` is `true`, performs `ex_.on_work_finished()`.

```
executor_type get_executor() const noexcept;
```

*Returns:* `ex_`.

```
bool owns_work() const noexcept;
```

*Returns:* `owns_`.

```
void reset() noexcept;
```

*Effects:* If `owns_` is `true`, performs `ex_.on_work_finished()`.

*Postconditions:* `owns_ == false`.

## Polymorphic executor wrappers

### General requirements on polymorphic executor wrappers

Polymorphic executors defined in this Technical Specification satisfy the `BaseExecutor`, `DefaultConstructible` (C++Std [defaultconstructible]), and `CopyAssignable` (C++Std [copyassignable]) requirements, and are defined as follows.

```
class C
{
public:
  class context_type; // TODO define this

  // construct / copy / destroy:

  C() noexcept;
  C(nullptr_t) noexcept;
  C(const executor& e) noexcept;
  C(executor&& e) noexcept;
  template<class Executor> C(Executor e);
  template<class Executor, class ProtoAllocator>
    C(allocator_arg_t, const ProtoAllocator& a, Executor e);

  C& operator=(const C& e) noexcept;
  C& operator=(C&& e) noexcept;
  C& operator=(nullptr_t) noexcept;
  template<class Executor> C& operator=(Executor e);

  ~C();

  // polymorphic executor modifiers:

  void swap(C& other) noexcept;
  template<class Executor, class ProtoAllocator>
    void assign(Executor e, const ProtoAllocator& a);

  // C operations:

  context_type context() const noexcept;

  // polymorphic executor capacity:

  explicit operator bool() const noexcept;

  // polymorphic executor target access:

  const type_info& target_type() const noexcept;
  template<class Executor> Executor* target() noexcept;
  template<class Executor> const Executor* target() const noexcept;
};

// polymorphic executor comparisons:

bool operator==(const C& a, const C& b) noexcept;
bool operator==(const C& e, nullptr_t) noexcept;
bool operator==(nullptr_t, const C& e) noexcept;
bool operator!=(const C& a, const C& b) noexcept;
bool operator!=(const C& e, nullptr_t) noexcept;
bool operator!=(nullptr_t, const C& e) noexcept;

// executor specialized algorithms:

void swap(C& a, C& b) noexcept;

// in namespace std:

template<class Allocator>
  struct uses_allocator<C, Allocator>
    : true_type {};
```

[*Note:* To meet the `noexcept` requirements for executor copy constructors and move constructors, implementations may share a target between two or more `executor` objects. *--end note*]

The *target* is the executor object that is held by the wrapper.

#### Polymorphic executor constructors

```
C() noexcept;
```

*Postconditions:* `!*this`.

```
C(nullptr_t) noexcept;
```

*Postconditions:* `!*this`.

```
C(const C& e) noexcept;
```

*Postconditions:* `!*this` if `!e`; otherwise, `*this` targets `e.target()` or a copy of `e.target()`.

```
C(C&& e) noexcept;
```

*Effects:* If `!e`, `*this` has no target; otherwise, moves `e.target()` or move-constructs the target of `e` into the target of `*this`, leaving `e` in a valid state with an unspecified value.

```
template<class Executor> C(Executor e);
```

*Effects:* `*this` targets a copy of `e` initialized with `std::move(e)`.

```
template<class Executor, class ProtoAllocator>
  C(allocator_arg_t, const ProtoAllocator& a, Executor e);
```

*Effects:* `*this` targets a copy of `e` initialized with `std::move(e)`.

A copy of the allocator argument is used to allocate memory, if necessary, for the internal data structures of the constructed `C` object.

#### Polymorphic executor assignment

```
C& operator=(const C& e) noexcept;
```

*Effects:* `C(e).swap(*this)`.

*Returns:* `*this`.

```
C& operator=(C&& e) noexcept;
```

*Effects:* Replaces the target of `*this` with the target of `e`, leaving `e` in a valid state with an unspecified value.

*Returns:* `*this`.

```
C& operator=(nullptr_t) noexcept;
```

*Effects:* `C(nullptr).swap(*this)`.

*Returns:* `*this`.

```
template<class Executor> C& operator=(Executor e);
```

*Effects:* `C(std::move(e)).swap(*this)`.

*Returns:* `*this`.

#### Polymorphic executor destructor

```
~C();
```

*Effects:* If `*this != nullptr`, releases shared ownership of, or destroys, the target of `*this`.

#### Polymorphic executor modifiers

```
void swap(C& other) noexcept;
```

*Effects:* Interchanges the targets of `*this` and `other`.

```
template<class Executor, class ProtoAllocator>
  void assign(Executor e, const ProtoAllocator& a);
```

*Effects:* `C(allocator_arg, a, std::move(e)).swap(*this)`.

#### Polymorphic executor operations

```
context_type context() const noexcept;
```

*Requires:* `*this != nullptr`.

*Returns:* A polymorphic wrapper for `e.context()`, where `e` is the target object of `*this`.

#### Polymorphic executor capacity

```
explicit operator bool() const noexcept;
```

*Returns:* `true` if `*this` has a target, otherwise `false`.

#### Polymorphic executor target access

```
const type_info& target_type() const noexcept;
```

*Returns:* If `*this` has a target of type `T`, `typeid(T)`; otherwise, `typeid(void)`.

```
template<class Executor> Executor* target() noexcept;
template<class Executor> const Executor* target() const noexcept;
```

*Returns:* If `target_type() == typeid(Executor)` a pointer to the stored executor target; otherwise a null pointer value.

#### Polymorphic executor comparisons

```
bool operator==(const C& a, const C& b) noexcept;
```

*Returns:*

- `true` if `!a` and `!b`;
- `true` if `a` and `b` share a target;
- `true` if `e` and `f` are the same type and `e == f`, where `e` is the target of `a` and `f` is the target of `b`;
- otherwise `false`.

```
bool operator==(const C& e, nullptr_t) noexcept;
bool operator==(nullptr_t, const C& e) noexcept;
```

*Returns:* `!e`.

```
bool operator!=(const C& a, const C& b) noexcept;
```

*Returns:* `!(a == b)`.

```
bool operator!=(const C& e, nullptr_t) noexcept;
bool operator!=(nullptr_t, const C& e) noexcept;
```

*Returns:* `(bool) e`.

#### Polymorphic executor specialized algorithms

```
void swap(C& a, C& b) noexcept;
```

*Effects:* `a.swap(b)`.

### Class `one_way_executor`

Class `one_way_executor` satisfies the general requirements on polymorphic executor wrappers, with the additional definitions below.

```
class one_way_executor
{
public:
  // execution agent creation
  template<class Function, class ProtoAllocator = std::allocator<void>>
    void execute(Function&& f, const ProtoAllocator& a = ProtoAllocator()) const;
};
```

Class `one_way_executor` satisfies the `OneWayExecutor` requirements. The target object shall satisfy the `OneWayExecutor` requirements.

```
template<class Function, class ProtoAllocator>
  void execute(Function&& f, const ProtoAllocator& a) const;
```

Let `e` be the target object of `*this`. Let `a1` be the allocator that was specified when the target was set. Let `fd` be the result of `DECAY_COPY(std::forward<Function>(f))`.

*Effects:* Performs `e.execute(g, a1)`, where `g` is a function object of unspecified type that, when called as `g()`, performs `fd()`. The allocator `a` is used to allocate any memory required to implement `g`.

### Class `non_blocking_one_way_executor`

Class `non_blocking_one_way_executor` satisfies the general requirements on polymorphic executor wrappers, with the additional definitions below.

```
class non_blocking_one_way_executor
{
public:
  // execution agent creation
  template<class Function, class ProtoAllocator = std::allocator<void>>
    void execute(Function&& f, const ProtoAllocator& a = ProtoAllocator()) const;
  template<class Function, class ProtoAllocator = std::allocator<void>>
    void post(Function&& f, const ProtoAllocator& a = ProtoAllocator()) const;
  template<class Function, class ProtoAllocator = std::allocator<void>>
    void defer(Function&& f, const ProtoAllocator& a = ProtoAllocator()) const;
};
```

Class `non_blocking_one_way_executor` satisfies the `NonBlockingOneWayExecutor` requirements. The target object shall satisfy the `NonBlockingOneWayExecutor` requirements.

```
template<class Function, class ProtoAllocator>
  void execute(Function&& f, const ProtoAllocator& a) const;
```

Let `e` be the target object of `*this`. Let `a1` be the allocator that was specified when the target was set. Let `fd` be the result of `DECAY_COPY(std::forward<Function>(f))`.

*Effects:* Performs `e.execute(g, a1)`, where `g` is a function object of unspecified type that, when called as `g()`, performs `fd()`. The allocator `a` is used to allocate any memory required to implement `g`.

```
template<class Function, class ProtoAllocator>
  void post(Function&& f, const ProtoAllocator& a) const;
```

Let `e` be the target object of `*this`. Let `a1` be the allocator that was specified when the target was set. Let `fd` be the result of `DECAY_COPY(std::forward<Function>(f))`.

*Effects:* Performs `e.post(g, a1)`, where `g` is a function object of unspecified type that, when called as `g()`, performs `fd()`. The allocator `a` is used to allocate any memory required to implement `g`.

```
template<class Function, class ProtoAllocator>
  void defer(Function&& f, const ProtoAllocator& a) const;
```

Let `e` be the target object of `*this`. Let `a1` be the allocator that was specified when the target was set. Let `fd` be the result of `DECAY_COPY(std::forward<Function>(f))`.

*Effects:* Performs `e.defer(g, a1)`, where `g` is a function object of unspecified type that, when called as `g()`, performs `fd()`. The allocator `a` is used to allocate any memory required to implement `g`.

### Class `two_way_executor`

Class `two_way_executor` satisfies the general requirements on polymorphic executor wrappers, with the additional definitions below.

```
class two_way_executor
{
public:
  // execution agent creation
  template<class Function, class ProtoAllocator = std::allocator<void>>
    result_of_t<decay_t<Function>()>
      sync_execute(Function&& f, const ProtoAllocator& a = ProtoAllocator()) const;
  template<class Function, class ProtoAllocator = std::allocator<void>>
    std::future<result_of_t<decay_t<Function>()>>
      async_execute(Function&& f, const ProtoAllocator& a = ProtoAllocator()) const;
};
```

Class `two_way_executor` satisfies the `TwoWayExecutor` requirements. The target object shall satisfy the `TwoWayExecutor` requirements.

```
template<class Function, class ProtoAllocator>
  result_of_t<decay_t<Function>()>
    sync_execute(Function&& f, const ProtoAllocator& a);
```

Let `e` be the target object of `*this`. Let `a1` be the allocator that was specified when the target was set. Let `fd` be the result of `DECAY_COPY(std::forward<Function>(f))`.

*Effects:* Performs `e.sync_execute(g, a1)`, where `g` is a function object of unspecified type that, when called as `g()`, performs `fd()`. The allocator `a` is used to allocate any memory required to implement `g`.

*Returns:* The return value of `fd()`.

```
template<class Function, class ProtoAllocator>
  std::future<result_of_t<decay_t<Function>()>>
    async_execute(Function&& f, const ProtoAllocator& a) const;
```

Let `e` be the target object of `*this`. Let `a1` be the allocator that was specified when the target was set. Let `fd` be the result of `DECAY_COPY(std::forward<Function>(f))`.

*Effects:* Performs `e.async_execute(g, a1)`, where `g` is a function object of unspecified type that, when called as `g()`, performs `fd()`. The allocator `a` is used to allocate any memory required to implement `g`.

*Returns:* A future with an associated shared state that will contain the result of `fd()`. [*Note:* `e.async_execute(g)` may return any future type that satisfies the Future requirements, and not necessarily `std::future`. One possible implementation approach is for the polymorphic wrapper to attach a continuation to the inner future via that object's `then()` member function. When invoked, this continuation stores the result in the outer future's associated shared and makes that shared state ready. *--end note*]

## Thread pools

Thread pools create execution agents which execute on threads without incurring the
overhead of thread creation and destruction whenever such agents are needed.

### Header `<thread_pool>` synopsis

```
namespace std {
namespace experimental {
inline namespace concurrency_v2 {

  class static_thread_pool;

} // inline namespace concurrency_v2
} // namespace experimental
} // namespace std
```

### Class `static_thread_pool`

`static_thread_pool` is a statically-sized thread pool which may be explicitly
grown via thread attachment. However, `static_thread_pool` does not
automatically change size. 

`static_thread_pool` presents an effectively unbounded input queue and the execution functions of `static_thread_pool`'s associated executors do not block on this input queue.

[*Note:* Because `static_thread_pool` provides parallel execution agents,
situations which require concurrent execution properties are not guaranteed
correctness. *--end note.*]

```
class static_thread_pool
{
  public:
    class executor_type;
    
    // construction/destruction
    explicit static_thread_pool(std::size_t num_threads);
    
    // nocopy
    static_thread_pool(const static_thread_pool&) = delete;
    static_thread_pool& operator=(const static_thread_pool&) = delete;

    // stop accepting incoming work and wait for work to drain
    ~static_thread_pool();

    // attach current thread to the thread pools list of worker threads
    void attach();

    // signal all work to complete
    void stop();

    // wait for all threads in the thread pool to complete
    void wait();

    // placeholder for a general approach to getting executors from 
    // standard contexts.
    executor_type executor() noexcept;
};

bool operator==(const static_thread_pool& a, const static_thread_pool& b) noexcept;
bool operator!=(const static_thread_pool& a, const static_thread_pool& b) noexcept;
```

The class `static_thread_pool` satisfies the `ExecutionContext` requirements.

For an object of type `static_thread_pool`, *outstanding work* is defined as the sum
of:

* the total number of calls to the `on_work_started` function that returned
  `true`, less the total number of calls to the `on_work_finished` function, on
  any executor associated with the `static_thread_pool`.

* the number of function objects that have been added to the `static_thread_pool`
  via the `static_thread_pool` executor, but not yet executed; and

* the number of function objects that are currently being executed by the
  `static_thread_pool`.

The `static_thread_pool` member functions `executor`, `attach`, `wait`, and `stop`,
and the `static_thread_pool::executor_type` copy constructors and member functions, do
not introduce data races as a result of concurrent calls to those functions
from different threads of execution.

#### Construction and destruction

```
static_thread_pool(std::size_t num_threads);
```

*Effects:* Constructs a `static_thread_pool` object with `num_threads` threads of
execution, as if by creating objects of type `std::thread`.

```
~static_thread_pool();
```

*Effects:* Destroys an object of class `static_thread_pool`. Performs `stop()`
followed by `wait()`.

#### Worker Management

```
void attach();
```

*Effects:* adds the calling thread to the pool of workers. Blocks the calling
thread until signalled to complete by `stop()` or `wait()`, and then blocks
until all the threads created during `static_thread_pool` object construction have
completed. (Note: The implementation is required to use
the attached thread to execute submitted function objects. RATIONALE:
implementations in terms of the Windows thread pool cannot utilise
user-provided threads. --end note) (NAMING: a possible alternate name for this
function is `join()`.)

```
void stop();
```

*Effects:* Signals the threads in the pool to complete as soon as possible. If
a thread is currently executing a function object, the thread will exit only
after completion of that function object. The call to `stop()` returns without
waiting for the threads to complete. Subsequent calls to attach complete
immediately.

```
void wait();
```

*Effects:* If not already stopped, signals the threads in the pool to complete
once the outstanding work is `0`. Blocks the calling thread (C++Std
[defns.block]) until all threads in the pool have completed, without executing
submitted function objects in the calling thread. Subsequent calls to attach
complete immediately.

*Synchronization:* The completion of each thread in the pool synchronizes with
(C++Std [intro.multithread]) the corresponding successful `wait()` return.

#### Executor Creation

```
executor_type executor() noexcept;
```

*Returns:* An executor that may be used to submit function objects to the
thread pool.

#### Comparisons

```
bool operator==(const static_thread_pool& a, const static_thread_pool& b) noexcept;
```

*Returns:* `std::addressof(a) == std::addressof(b)`.

```
bool operator!=(const static_thread_pool& a, const static_thread_pool& b) noexcept;
```

*Returns:* `!(a == b)`.

### Class `static_thread_pool::executor_type`

```
class static_thread_pool::executor_type
{
  public:
    // types:

    typedef parallel_execution_tag execution_category;
    typedef possibly_blocking_execution_tag blocking_category;
    typedef std::size_t shape_type;
    typedef std::size_t index_type;

    // construct / copy / destroy:

    executor_type(const executor_type& other) noexcept;
    executor_type(executor_type&& other) noexcept;

    executor_type& operator=(const executor_type& other) noexcept;
    executor_type& operator=(executor_type&& other) noexcept;

    // executor operations:

    bool running_in_this_thread() const noexcept;

    static_thread_pool& context() const noexcept;

    bool on_work_started() const noexcept;
    void on_work_finished() const noexcept;
};

bool operator==(const static_thread_pool::executor_type& a,
                const static_thread_pool::executor_type& b) noexcept;
bool operator!=(const static_thread_pool::executor_type& a,
                const static_thread_pool::executor_type& b) noexcept;
```

`static_thread_pool::executor_type` is a type satisfying the `BaseExecutor` and
`ExecutorWorkTracker` requirements. Objects of type
`static_thread_pool::executor` are associated with a `static_thread_pool`.

The customization points `execute`, `post`, `defer`, `sync_execute`,
`async_execute`, `async_post`, `async_defer`, `then_execute`, `bulk_execute`,
`bulk_post`, `bulk_defer`, `bulk_sync_execute`, `bulk_async_execute`,
`bulk_async_post`, `bulk_async_defer`, and `bulk_then_execute` are well-formed
for this executor. Function objects submitted using these customization points
will be executed by the `static_thread_pool`.

For the customization points `execute`, `sync_execute`, `async_execute`,
`bulk_execute`, `bulk_sync_execute`, and `bulk_async_execute`, if
`running_in_this_thread()` is `true`, calls at least one of the submitted
function objects in the current thread prior to returning from the
customization point. [*Note:* If this function object exits via an exception,
the exception propagates to the caller. *--end note*]

#### Constructors

```
executor_type(const executor_type& other) noexcept;
```

*Postconditions:* `*this == other`.

```
executor_type(executor_type&& other) noexcept;
```

*Postconditions:* `*this` is equal to the prior value of `other`.

#### Assignment

```
executor_type& operator=(const executor_type& other) noexcept;
```

*Postconditions:* `*this == other`.

*Returns:* `*this`.

```
executor_type& operator=(executor_type&& other) noexcept;
```

*Postconditions:* `*this` is equal to the prior value of `other`.

*Returns:* `*this`.

#### Operations

```
bool running_in_this_thread() const noexcept;
```

*Returns:* `true` if the current thread of execution is a thread that was
created by or attached to the associated `static_thread_pool` object.

```
static_thread_pool& context() const noexcept;
```

*Returns:* A reference to the associated `static_thread_pool` object.

```
bool on_work_started() const noexcept;
```

*Effects:* Increments the count of outstanding work associated with the
`static_thread_pool`.

*Returns:* `false` if there was a prior call to the `stop()` member function of
the associated `static_thread_pool` object; otherwise `true`.

```
void on_work_finished() const noexcept;
```

*Effects:* Decrements the count of outstanding work associated with the
`static_thread_pool`.

#### Comparisons

```
bool operator==(const static_thread_pool::executor_type& a,
                const static_thread_pool::executor_type& b) noexcept;
```

*Returns:* `a.context() == b.context()`.

```
bool operator!=(const static_thread_pool::executor_type& a,
                const static_thread_pool::executor_type& b) noexcept;
```

*Returns:* `!(a == b)`.

## Interoperation with existing facilities

### Execution policy interoperation

```
class parallel_execution_policy
{
  public:
    // types:
    using execution_category = parallel_execution_tag;
    using executor_type = implementation-defined;

    // executor access
    const executor_type& executor() const noexcept;

    // execution policy factory
    template<class Executor>
    see-below on(Executor&& exec) const;
};

class sequenced_execution_tag { by-analogy-to-parallel_execution_policy };
class parallel_unsequenced_execution_tag { by-analogy-to-parallel_execution_policy };
```

#### Associated executor

Each execution policy is associated with an executor, and this executor is called its *associated executor*.

The type of an execution policy's associated executor shall satisfy the requirements of `BulkTwoWayExecutor`.

When an execution policy is used as a parameter to a parallel algorithm, the
execution agents that invoke element access functions are created by the
execution policy's associated executor.

The type of an execution policy's associated executor is the member type `executor_type`.

#### Execution category

Each execution policy is categorized by an *execution category*.

When an execution policy is used as a parameter to a parallel algorithm, the
execution agents it creates are guaranteed to make forward progress and
execute invocations of element access functions as ordered by its execution
category.

An execution policy's execution category is given by the member type `execution_category`.

The execution category of an execution policy's associated executor shall not be weaker than the execution policy's execution category.

#### Associated executor access

```
const executor_type& executor() const noexcept;
```

*Returns:* The execution policy's associated executor.

#### Execution policy factory

```
template<class Executor>
see-below on(Executor&& exec) const;
```

Let `T` be `decay_t<Executor>`.

*Returns:* An execution policy whose execution category is `execution_category`. If `T` satisfies the requirements of
`BulkTwoWayExecutor`, the returned execution policy's associated executor is equal to `exec`. Otherwise,
the returned execution policy's associated executor fulfills the `BulkTwoWayExecutor` requirements which creates execution agents using a copy of `exec`.

*Remarks:* This member function shall not participate in overload resolution unless `is_executor_v<T>` is `true` and
`executor_execution_category_t<T>` is as strong as `execution_category`.

### Control structure interoperation

#### Function template `async`

The function template `async` provides a mechanism to invoke a function in a new
execution agent created by an executor and provides the result of the function in the
future object with which it shares a state.

```
template<class Executor, class Function, class... Args>
executor_future_t<Executor, result_of_t<decay_t<Function>(decay_t<Args>...)>>
async(const Executor& exec, Function&& f, Args&&... args);
```

*Returns:* Equivalent to:

    auto __g = bind(std::forward<Function>(f), std::forward<Args>(args)...);
    return execution::async_post(exec, [__g = move(__g)]{ return INVOKE(__g); });

#### `std::experimental::future::then()`

The member function template `then` provides a mechanism for attaching a *continuation* to a `std::future` object,
which will be executed on a new execution agent created by an executor.

```
template<class T>
template<class Executor, class Function>
executor_future_t<Executor, see-below>
future<T>::then(const Executor& exec, Function&& f);
```

2. TODO: Concrete specification

The general idea of this overload of `.then()` is that it accepts a
particular type of `OneWayExecutor` that cannot block in `.execute()`.
`.then()` stores `f` as the next continuation in the future state, and when
the future is ready, creates an execution agent using a copy of `exec`.

One approach is for `.then()` to require a `NonBlockingOneWayExecutor`, and to
specify that `.then()` submits the continuation using `exec.post()` if the
future is already ready at the time when `.then()` is called, and to submit
using `exec.execute()` otherwise.

#### `std::experimental::shared_future::then()`

The member function template `then` provides a mechanism for attaching a *continuation* to a `std::shared_future` object,
which will be executed on a new execution agent created by an executor.

```
template<class T>
template<class Executor, class Function>
executor_future_t<Executor, see-below>
shared_future<T>::then(const Executor& exec, Function&& f);
```

TODO: Concrete specification

The general idea of this overload of `.then()` is that it accepts a
particular type of `OneWayExecutor` that cannot block in `.execute()`.
`.then()` stores `f` as the next continuation in the underlying future
state, and when the underlying future is ready, creates an execution agent
using a copy of `exec`.

One approach is for `.then()` to require a `NonBlockingOneWayExecutor`, and to
specify that `.then()` submits the continuation using `exec.post()` if the
future is already ready at the time when `.then()` is called, and to submit
using `exec.execute()` otherwise.

#### Function template `invoke`

The function template `invoke` provides a mechanism to invoke a function in a new
execution agent created by an executor and return result of the function.

```
template<class Executor, class Function, class... Args>
result_of_t<F&&(Args&&...)>
invoke(const Executor& exec, Function&& f, Args&&... args);
```

*Returns:* Equivalent to:

`return execution::sync_execute(exec, [&]{ return INVOKE(f, args...); });`

#### Task block

##### Function template `define_task_block_restore_thread()`

```
template<class Executor, class F>
void define_task_block_restore_thread(const Executor& exec, F&& f);
```

*Requires:* Given an lvalue `tb` of type `task_block`, the expression `f(tb)` shall be well-formed.

*Effects:* Constructs a `task_block tb`, creates a new execution agent, and calls `f(tb)` on that execution agent.

*Throws:* `exception_list`, as specified in version two of the Paralellism TS.

*Postconditions:* All tasks spawned from `f` have finished execution.

*Remarks:* Unlike `define_task_block`, `define_task_block_restore_thread` always returns on the same thread as the one on which it was called.

##### `task_block` member function template `run`

```
template<class Executor, class F>
void run(const Executor& exec, F&& f);
```

*Requires:* `F` shall be `MoveConstructible`. `DECAY_COPY(std::forward<F>(f))()` shall be a valid expression.

*Preconditions:* `*this` shall be an active `task_block`.

*Effects:* Evaluates `DECAY_COPY(std::forward<F>(f))()`, where `DECAY_COPY(std::forward<F>(f))` is evaluated synchronously within the current thread.
The call to the resulting copy of the function object is permitted to run on an execution agent created by `exec` in an unordered fashion relative to
the sequence of operations following the call to `run(exec, f)` (the continuation), or indeterminately-sequenced within the same thread as the continuation.
The call to `run` synchronizes with the next invocation of `wait` on the same `task_block` or completion of the nearest enclosing `task_block` (i.e., the `define_task_block` or
`define_task_block_restore_thread` that created this `task_block`.

*Throws:* `task_cancelled_exception`, as described in version 2 of the Parallelism TS.

# Relationship to other proposals and specifications

## Networking TS

Executors in the Networking TS may be defined as refinements of the type requirements in this proposal, as illustrated below. In addition to these requirements, some minor changes would be required to member function names and parameters used in the Networking TS, to conform to the requirements defined in this proposal.

### `NetworkingExecutor` requirements

A type `X` satisfies the `NetworkingExecutor` requirements if it satisfies the `NonBlockingOneWayExecutor` requirements, the `ExecutorWorkTracker` requirements, and satisfies the additional requirements listed below.

In the Table \ref{net_execution_context_requirements} below, `x` denotes a (possibly const) value of type `X`.

| expression    | return type   | assertion/note pre/post-condition |
|---------------|----------------------------|----------------------|
| `x.context()` | `net::execution_context&`, or `E&` where `E` is a type that satisfies the `NetworkingExecutionContext` requirements. | |

### `NetworkingExecutionContext` requirements

A type `X` satisfies the `NetworkingExecutionContext` requirements if it satisfies the `ExecutionContext` requirements, is publicly and unambiguously derived from `net::execution_context`, and satisfies the additional requirements listed below.

In the Table \ref{net_execution_context_requirements} below, `x` denotes a value of type `X`.

Table: (NetworkingExecutionContext requirements) \label{net_execution_context_requirements}

| expression    | return type   | assertion/note pre/post-condition |
|---------------|----------------------------|----------------------|
| `X::executor_type` | type meeting `NetworkingExecutor` requirements | |
| `x.~X()` | | Destroys all unexecuted function objects that were submitted via an executor object that is associated with the execution context. |
| `x.get_executor()` | `X::executor_type` | Returns an executor object that is associated with the execution context. |

# Appendix

## Code Examples {#code-examples}

These short code examples demonstrate how we expect programmers to use executors to create execution in different use cases.

### Simple use of an executor

A programmer may create an asynchronous task via `async()` by providing an executor obtained from a thread pool:

    using namespace std::experimental::concurrency_v2;

    // create a thread pool object
    static_thread_pool pool(4);

    // obtain an executor from the thread pool
    auto exec = pool.executor()

    auto my_task = ...

    // compose the thread pool's executor with async:
    async(exec, my_task);

In this example, the executor parameter provides `std::async()` with explicit requirements concerning how to create the work responsible for executing the task.

Similarly, a programmer may require that the work created by a parallel algorithm happen "on" an executor:

    using namespace std::experimental::concurrency_v2;

    // create a thread pool object
    static_thread_pool pool(4);

    // obtain an executor from the thread pool
    auto exec = pool.executor()

    auto my_task = ...

    // compose the thread pool's executor with the par execution policy using .on():
    for_each(execution::par.on(exec), vec.begin(), vec.end(), my_task);

In this example, the executor parameter composes with `par` to create a new execution policy associated with the thread pool's executor. 

### Use of an executor in a generic context

Functions may receive executors as generic template parameters. Our proposal
provides tools for working in generic contexts while retaining the ability to
manipulate executors uniformly. For example, consider this implementation of a
hypothetical math library's parallel `dot()` product function:

    template<class BulkTwoWayExecutor>
    float dot(const BulkTwoWayExecutor& exec, const float* data1, const float* data2, size_t n)
    {
      auto zipped = zip_with(std::multiplies<>(), data1, data2);
      return std::reduce(std::execution::par.on(exec), zipped, zipped + n, 0.f, std::plus<>());
    }

Because it is a template, the `dot()` function has no concrete information
about `exec`, besides the fact that the executor satisfies the requirements of
our `BulkTwoWayExecutor` concept. However, this is all the information
necessary to compose `exec` correctly with `par` and `std::reduce`.

Programmers may work at a lower level yet retain generality by manipulating an
executor through customization points. For example, consider this hypothetical
implementation of `async()`:

    template<class Executor, class Function, class... Args>
    auto async(const Executor& exec, Function&& f, Args&&... args)
    {
      // bind f and args together
      auto g = bind(f, args...);

      using namespace std::experimental::concurrency_v2;

      // use the customization point execution::async_execute() to asynchronously invoke g and return a future
      return execution::async_execute(exec, g);
    }

Even if the executor in this example does not natively support the
`async_execute()` operation through a member or free function, the executor may
still be used as if it does support this operation. If native support does not
exist, the customization point applies an adaptation to whatever native
operations do exist to create the desired operation.
 
### Defining executors

A programmer creates an executor by defining a type with one or more execution
functions defined as members or free functions as well as other members related
to executor identity.

For example, an executor which creates a new thread for each execution agent
may define the `execute()` method:

    struct per_thread_executor
    {
      template<class Function>
      void execute(Function&& f) const
      {
        std::thread new_thread(std::forward<Function>(f));

        new_thread.detach();
      }

      const per_thread_executor& context() const noexcept
      {
        return *this;
      }

      bool operator==(const per_thread_executor&) const noexcept
      {
        return true;
      }

      bool operator!=(const per_thread_executor&) const noexcept
      {
        return false;
      }
    };

An executor which executes work immediately within the calling thread may define the `sync_execute()` method:

    struct inline_executor
    {
      template<class Function>
      auto sync_execute(Function&& f) const
      {
        return std::forward<Function>(f)();
      }

      const inline_executor& context() const noexcept
      {
        return *this;
      }

      bool operator==(const inline_executor&) const noexcept
      {
        return true;
      }

      bool operator!=(const inline_executor&) const noexcept
      {
        return false;
      }
    };

An executor which executes parallel work in bulk using OpenMP may define the `bulk_sync_execute()` method:

    struct openmp_executor
    {
      using execution_category = parallel_execution_tag;

      template<class Function, class ResultFactory, class SharedFactory>
      auto bulk_sync_execute(Function f, size_t n, ResultFactory result_factory, SharedFactory shared_factory) const
      {
        auto result = result_factory();
        auto shared = shared_factory();

        #pragma omp parallel for
        for(size_t i = 0; i < n; ++i)
        {
          f(i, result, shared);
        }

        return result;
      }

      const openmp_executor& context() const noexcept
      {
        return *this;
      }

      bool operator==(const openmp_executor&) const noexcept
      {
        return true;
      }

      bool operator!=(const openmp_executor&) const noexcept
      { 
        return false;
      }
    };

